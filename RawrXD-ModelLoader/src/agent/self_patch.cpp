#include "self_patch.hpp"
#include <QFile>
#include <QTextStream>
#include <QProcess>
#include <QDir>
#include <QCoreApplication>
#include <QTimer>
#include <QDebug>

SelfPatch::SelfPatch(QObject* parent) : QObject(parent) {}

bool SelfPatch::addKernel(const QString& name, const QString& templateName) {
    QString tplPath = QString("kernels/%1.comp").arg(templateName);
    QString outPath = QString("kernels/%1.comp").arg(name);
    
    // Check if already exists (idempotent)
    if (QFile::exists(outPath)) {
        qDebug() << "Kernel" << name << "already exists";
        emit kernelAdded(name);
        return true;
    }
    
    // Copy template
    if (!QFile::copy(tplPath, outPath)) {
        qWarning() << "Failed to copy template" << tplPath << "to" << outPath;
        return false;
    }
    
    // Inject compile command into CMakeLists.txt
    QFile cmake("CMakeLists.txt");
    if (!cmake.open(QIODevice::ReadOnly | QIODevice::Text)) {
        qWarning() << "Failed to open CMakeLists.txt";
        return false;
    }
    
    QString txt = QString::fromUtf8(cmake.readAll());
    cmake.close();
    
    // Add custom command for shader compilation
    QString cmd = QString(R"(
# Auto-generated shader compilation for %1
add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/%1.comp.spv.h
    COMMAND glslangValidator -V kernels/%1.comp -o ${CMAKE_CURRENT_BINARY_DIR}/tmp_%1.spv
    COMMAND xxd -i tmp_%1.spv > ${CMAKE_CURRENT_BINARY_DIR}/%1.comp.spv.h
    DEPENDS kernels/%1.comp
    COMMENT "Building %1 shader"
    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
)
add_custom_target(%1_spv DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/%1.comp.spv.h)
)").arg(name);
    
    txt += "\n" + cmd;
    
    if (!cmake.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qWarning() << "Failed to write CMakeLists.txt";
        return false;
    }
    cmake.write(txt.toUtf8());
    cmake.close();
    
    qDebug() << "Added kernel" << name;
    emit kernelAdded(name);
    return true;
}

bool SelfPatch::addCpp(const QString& name, const QString& deps) {
    QString hppPath = QString("src/gpu/%1.hpp").arg(name);
    QString cppPath = QString("src/gpu/%1.cpp").arg(name);
    
    // Check if already exists
    if (QFile::exists(cppPath)) {
        qDebug() << "C++ file" << name << "already exists";
        emit cppAdded(name);
        return true;
    }
    
    // Create directory if needed
    QDir().mkpath("src/gpu");
    
    // Write header
    QFile hppFile(hppPath);
    if (!hppFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qWarning() << "Failed to create" << hppPath;
        return false;
    }
    
    QString hppContent = QString(R"(#pragma once
#include <QByteArray>
#include <cstddef>

class %1 {
public:
    static QByteArray wrap(const float* src, size_t n);
    static void initialize();
    static void cleanup();
};
)").arg(name);
    
    hppFile.write(hppContent.toUtf8());
    hppFile.close();
    
    // Write implementation
    QFile cppFile(cppPath);
    if (!cppFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qWarning() << "Failed to create" << cppPath;
        return false;
    }
    
    QString cppContent = QString(R"(#include "%1.hpp"
#include <vulkan/vulkan.h>
#include <QDebug>

// External shader data generated by CMake
extern "C" const unsigned char %2_comp_spv[];
extern "C" const unsigned int %2_comp_spv_len;

static VkDevice s_device = VK_NULL_HANDLE;
static VkShaderModule s_shader = VK_NULL_HANDLE;

void %1::initialize() {
    // TODO: Initialize Vulkan resources
    qDebug() << "Initializing %1";
}

void %1::cleanup() {
    if (s_shader != VK_NULL_HANDLE && s_device != VK_NULL_HANDLE) {
        vkDestroyShaderModule(s_device, s_shader, nullptr);
        s_shader = VK_NULL_HANDLE;
    }
}

QByteArray %1::wrap(const float* src, size_t n) {
    // Real Vulkan compute shader dispatch
    if (s_device == VK_NULL_HANDLE || s_shader == VK_NULL_HANDLE) {
        qWarning() << "Vulkan resources not initialized for %1";
        QByteArray fallback(n * sizeof(float), 0);
        memcpy(fallback.data(), src, n * sizeof(float));
        return fallback;
    }
    
    // Allocate GPU buffers for input and output
    VkBuffer inputBuffer, outputBuffer;
    VkDeviceMemory inputMemory, outputMemory;
    VkDeviceSize bufferSize = n * sizeof(float);
    
    // Create input buffer with source data
    VkBufferCreateInfo inputBufferInfo{};
    inputBufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    inputBufferInfo.size = bufferSize;
    inputBufferInfo.usage = VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
    inputBufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
    
    if (vkCreateBuffer(s_device, &inputBufferInfo, nullptr, &inputBuffer) != VK_SUCCESS) {
        qWarning() << "Failed to create input buffer";
        QByteArray fallback(n * sizeof(float), 0);
        memcpy(fallback.data(), src, n * sizeof(float));
        return fallback;
    }
    
    // Create output buffer for results
    VkBufferCreateInfo outputBufferInfo = inputBufferInfo;
    outputBufferInfo.usage = VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
    
    if (vkCreateBuffer(s_device, &outputBufferInfo, nullptr, &outputBuffer) != VK_SUCCESS) {
        qWarning() << "Failed to create output buffer";
        vkDestroyBuffer(s_device, inputBuffer, nullptr);
        QByteArray fallback(n * sizeof(float), 0);
        memcpy(fallback.data(), src, n * sizeof(float));
        return fallback;
    }
    
    // Allocate device memory for buffers
    VkMemoryRequirements memReqs;
    vkGetBufferMemoryRequirements(s_device, inputBuffer, &memReqs);
    
    VkMemoryAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    allocInfo.allocationSize = memReqs.size;
    // Find suitable memory type (preferably device-local)
    allocInfo.memoryTypeIndex = 0;
    
    if (vkAllocateMemory(s_device, &allocInfo, nullptr, &inputMemory) != VK_SUCCESS) {
        qWarning() << "Failed to allocate input buffer memory";
        vkDestroyBuffer(s_device, inputBuffer, nullptr);
        vkDestroyBuffer(s_device, outputBuffer, nullptr);
        QByteArray fallback(n * sizeof(float), 0);
        memcpy(fallback.data(), src, n * sizeof(float));
        return fallback;
    }
    
    if (vkAllocateMemory(s_device, &allocInfo, nullptr, &outputMemory) != VK_SUCCESS) {
        qWarning() << "Failed to allocate output buffer memory";
        vkFreeMemory(s_device, inputMemory, nullptr);
        vkDestroyBuffer(s_device, inputBuffer, nullptr);
        vkDestroyBuffer(s_device, outputBuffer, nullptr);
        QByteArray fallback(n * sizeof(float), 0);
        memcpy(fallback.data(), src, n * sizeof(float));
        return fallback;
    }
    
    // Bind memory to buffers
    vkBindBufferMemory(s_device, inputBuffer, inputMemory, 0);
    vkBindBufferMemory(s_device, outputBuffer, outputMemory, 0);
    
    // Map and copy input data
    void* data;
    vkMapMemory(s_device, inputMemory, 0, bufferSize, 0, &data);
    memcpy(data, src, bufferSize);
    vkUnmapMemory(s_device, inputMemory);
    
    // Create compute pipeline (descriptor set layout, pipeline layout, pipeline)
    VkDescriptorSetLayoutBinding bindings[2]{};
    
    // Input buffer binding
    bindings[0].binding = 0;
    bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
    bindings[0].descriptorCount = 1;
    bindings[0].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
    
    // Output buffer binding
    bindings[1].binding = 1;
    bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
    bindings[1].descriptorCount = 1;
    bindings[1].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
    
    VkDescriptorSetLayoutCreateInfo layoutInfo{};
    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    layoutInfo.bindingCount = 2;
    layoutInfo.pBindings = bindings;
    
    // Create pipeline layout
    VkPipelineLayout pipelineLayout;
    vkCreatePipelineLayout(s_device, nullptr, nullptr, &pipelineLayout);
    
    // Create compute pipeline
    VkComputePipelineCreateInfo pipelineInfo{};
    pipelineInfo.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
    pipelineInfo.stage.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    pipelineInfo.stage.stage = VK_SHADER_STAGE_COMPUTE_BIT;
    pipelineInfo.stage.module = s_shader;
    pipelineInfo.stage.pName = "main";
    pipelineInfo.layout = pipelineLayout;
    
    VkPipeline computePipeline;
    if (vkCreateComputePipelines(s_device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &computePipeline) != VK_SUCCESS) {
        qWarning() << "Failed to create compute pipeline";
        vkDestroyBuffer(s_device, inputBuffer, nullptr);
        vkDestroyBuffer(s_device, outputBuffer, nullptr);
        vkFreeMemory(s_device, inputMemory, nullptr);
        vkFreeMemory(s_device, outputMemory, nullptr);
        QByteArray fallback(n * sizeof(float), 0);
        memcpy(fallback.data(), src, n * sizeof(float));
        return fallback;
    }
    
    // Execute compute shader on command buffer
    VkCommandPoolCreateInfo poolInfo{};
    poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
    
    VkCommandPool cmdPool;
    vkCreateCommandPool(s_device, &poolInfo, nullptr, &cmdPool);
    
    VkCommandBufferAllocateInfo allocCmdInfo{};
    allocCmdInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocCmdInfo.commandPool = cmdPool;
    allocCmdInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocCmdInfo.commandBufferCount = 1;
    
    VkCommandBuffer cmdBuffer;
    vkAllocateCommandBuffers(s_device, &allocCmdInfo, &cmdBuffer);
    
    // Record compute commands
    VkCommandBufferBeginInfo beginInfo{};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    vkBeginCommandBuffer(cmdBuffer, &beginInfo);
    
    vkCmdBindPipeline(cmdBuffer, VK_PIPELINE_BIND_POINT_COMPUTE, computePipeline);
    
    // Dispatch compute shader with workgroups
    uint32_t workgroupSize = 256; // Typical workgroup size
    uint32_t numWorkgroups = (n + workgroupSize - 1) / workgroupSize;
    vkCmdDispatch(cmdBuffer, numWorkgroups, 1, 1);
    
    // Memory barrier after compute
    VkMemoryBarrier barrier{};
    barrier.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
    barrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;
    barrier.dstAccessMask = VK_ACCESS_HOST_READ_BIT;
    vkCmdPipelineBarrier(cmdBuffer, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
                         VK_PIPELINE_STAGE_HOST, 0, 1, &barrier, 0, nullptr, 0, nullptr);
    
    vkEndCommandBuffer(cmdBuffer);
    
    // Submit command buffer to queue
    VkQueue computeQueue;
    vkGetDeviceQueue(s_device, 0, 0, &computeQueue);
    
    VkSubmitInfo submitInfo{};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &cmdBuffer;
    
    VkFence fence;
    VkFenceCreateInfo fenceInfo{};
    fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
    vkCreateFence(s_device, &fenceInfo, nullptr, &fence);
    
    vkQueueSubmit(computeQueue, 1, &submitInfo, fence);
    vkWaitForFences(s_device, 1, &fence, VK_TRUE, UINT64_MAX);
    
    // Read back results from GPU
    QByteArray result(bufferSize, 0);
    vkMapMemory(s_device, outputMemory, 0, bufferSize, 0, &data);
    memcpy(result.data(), data, bufferSize);
    vkUnmapMemory(s_device, outputMemory);
    
    // Cleanup resources
    vkDestroyFence(s_device, fence, nullptr);
    vkDestroyCommandPool(s_device, cmdPool, nullptr);
    vkDestroyPipeline(s_device, computePipeline, nullptr);
    vkDestroyPipelineLayout(s_device, pipelineLayout, nullptr);
    vkDestroyBuffer(s_device, inputBuffer, nullptr);
    vkDestroyBuffer(s_device, outputBuffer, nullptr);
    vkFreeMemory(s_device, inputMemory, nullptr);
    vkFreeMemory(s_device, outputMemory, nullptr);
    
    qDebug() << "Vulkan compute shader executed for" << n << "elements";
    return result;
}
)").arg(name, deps);
    
    cppFile.write(cppContent.toUtf8());
    cppFile.close();
    
    qDebug() << "Added C++ wrapper" << name;
    emit cppAdded(name);
    return true;
}

bool SelfPatch::hotReload() {
    emit reloadStarted();
    
    // Step 1: Build the project
    qDebug() << "Starting rebuild...";
    QProcess buildProc;
    buildProc.start("cmake", {"--build", "build", "--config", "Release", "--target", "RawrXD-QtShell"});
    
    if (!buildProc.waitForFinished(120000)) { // 2 minute timeout
        qWarning() << "Build timeout";
        emit reloadCompleted(false);
        return false;
    }
    
    if (buildProc.exitCode() != 0) {
        qWarning() << "Build failed:" << buildProc.readAllStandardError();
        emit reloadCompleted(false);
        return false;
    }
    
    qDebug() << "Build successful";
    
    // Step 2: Spawn new process
    QString newBin = QDir::current().absoluteFilePath("build/bin/Release/RawrXD-QtShell.exe");
    QStringList args = QCoreApplication::arguments();
    args.removeFirst(); // Remove program name
    
    qint64 pid;
    if (!QProcess::startDetached(newBin, args, QDir::currentPath(), &pid)) {
        qWarning() << "Failed to start new process";
        emit reloadCompleted(false);
        return false;
    }
    
    qDebug() << "New process started with PID" << pid;
    
    // Step 3: Suicide after 500ms (let new process take over sockets/resources)
    QTimer::singleShot(500, qApp, [this]() {
        qDebug() << "Exiting old process for hot-reload";
        emit reloadCompleted(true);
        QCoreApplication::quit();
    });
    
    return true;
}

bool SelfPatch::patchFile(const QString& filename, const QString& patch) {
    QFile file(filename);
    if (!file.open(QIODevice::ReadWrite | QIODevice::Text)) {
        qWarning() << "Failed to open file for patching:" << filename;
        return false;
    }
    
    QString content = QString::fromUtf8(file.readAll());
    
    // Simple patch application (append or replace)
    if (patch.startsWith("APPEND:")) {
        content += patch.mid(7);
    } else if (patch.startsWith("REPLACE:")) {
        // Format: REPLACE:oldText->newText
        QStringList parts = patch.mid(8).split("->");
        if (parts.size() == 2) {
            content.replace(parts[0], parts[1]);
        }
    } else {
        // Default: append
        content += "\n" + patch;
    }
    
    file.seek(0);
    file.write(content.toUtf8());
    file.resize(file.pos());
    file.close();
    
    qDebug() << "Patched file:" << filename;
    return true;
}
