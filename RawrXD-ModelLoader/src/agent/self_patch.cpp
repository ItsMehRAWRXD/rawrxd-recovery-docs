#include "self_patch.hpp"
#include <QFile>
#include <QTextStream>
#include <QProcess>
#include <QDir>
#include <QCoreApplication>
#include <QTimer>
#include <QDebug>

SelfPatch::SelfPatch(QObject* parent) : QObject(parent) {}

bool SelfPatch::addKernel(const QString& name, const QString& templateName) {
    QString tplPath = QString("kernels/%1.comp").arg(templateName);
    QString outPath = QString("kernels/%1.comp").arg(name);
    
    // Check if already exists (idempotent)
    if (QFile::exists(outPath)) {
        qDebug() << "Kernel" << name << "already exists";
        emit kernelAdded(name);
        return true;
    }
    
    // Copy template
    if (!QFile::copy(tplPath, outPath)) {
        qWarning() << "Failed to copy template" << tplPath << "to" << outPath;
        return false;
    }
    
    // Inject compile command into CMakeLists.txt
    QFile cmake("CMakeLists.txt");
    if (!cmake.open(QIODevice::ReadOnly | QIODevice::Text)) {
        qWarning() << "Failed to open CMakeLists.txt";
        return false;
    }
    
    QString txt = QString::fromUtf8(cmake.readAll());
    cmake.close();
    
    // Add custom command for shader compilation
    QString cmd = QString(R"(
# Auto-generated shader compilation for %1
add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/%1.comp.spv.h
    COMMAND glslangValidator -V kernels/%1.comp -o ${CMAKE_CURRENT_BINARY_DIR}/tmp_%1.spv
    COMMAND xxd -i tmp_%1.spv > ${CMAKE_CURRENT_BINARY_DIR}/%1.comp.spv.h
    DEPENDS kernels/%1.comp
    COMMENT "Building %1 shader"
    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
)
add_custom_target(%1_spv DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/%1.comp.spv.h)
)").arg(name);
    
    txt += "\n" + cmd;
    
    if (!cmake.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qWarning() << "Failed to write CMakeLists.txt";
        return false;
    }
    cmake.write(txt.toUtf8());
    cmake.close();
    
    qDebug() << "Added kernel" << name;
    emit kernelAdded(name);
    return true;
}

bool SelfPatch::addCpp(const QString& name, const QString& deps) {
    QString hppPath = QString("src/gpu/%1.hpp").arg(name);
    QString cppPath = QString("src/gpu/%1.cpp").arg(name);
    
    // Check if already exists
    if (QFile::exists(cppPath)) {
        qDebug() << "C++ file" << name << "already exists";
        emit cppAdded(name);
        return true;
    }
    
    // Create directory if needed
    QDir().mkpath("src/gpu");
    
    // Write header
    QFile hppFile(hppPath);
    if (!hppFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qWarning() << "Failed to create" << hppPath;
        return false;
    }
    
    QString hppContent = QString(R"(#pragma once
#include <QByteArray>
#include <cstddef>

class %1 {
public:
    static QByteArray wrap(const float* src, size_t n);
    static void initialize();
    static void cleanup();
};
)").arg(name);
    
    hppFile.write(hppContent.toUtf8());
    hppFile.close();
    
    // Write implementation
    QFile cppFile(cppPath);
    if (!cppFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qWarning() << "Failed to create" << cppPath;
        return false;
    }
    
    QString cppContent = QString(R"(#include "%1.hpp"
#include <vulkan/vulkan.h>
#include <QDebug>

// External shader data generated by CMake
extern "C" const unsigned char %2_comp_spv[];
extern "C" const unsigned int %2_comp_spv_len;

static VkDevice s_device = VK_NULL_HANDLE;
static VkShaderModule s_shader = VK_NULL_HANDLE;

void %1::initialize() {
    // TODO: Initialize Vulkan resources
    qDebug() << "Initializing %1";
}

void %1::cleanup() {
    if (s_shader != VK_NULL_HANDLE && s_device != VK_NULL_HANDLE) {
        vkDestroyShaderModule(s_device, s_shader, nullptr);
        s_shader = VK_NULL_HANDLE;
    }
}

QByteArray %1::wrap(const float* src, size_t n) {
    // TODO: Call Vulkan compute shader created by addKernel
    // This is a placeholder implementation
    QByteArray result(n * sizeof(float), 0);
    memcpy(result.data(), src, n * sizeof(float));
    return result;
}
)").arg(name, deps);
    
    cppFile.write(cppContent.toUtf8());
    cppFile.close();
    
    qDebug() << "Added C++ wrapper" << name;
    emit cppAdded(name);
    return true;
}

bool SelfPatch::hotReload() {
    emit reloadStarted();
    
    // Step 1: Build the project
    qDebug() << "Starting rebuild...";
    QProcess buildProc;
    buildProc.start("cmake", {"--build", "build", "--config", "Release", "--target", "RawrXD-QtShell"});
    
    if (!buildProc.waitForFinished(120000)) { // 2 minute timeout
        qWarning() << "Build timeout";
        emit reloadCompleted(false);
        return false;
    }
    
    if (buildProc.exitCode() != 0) {
        qWarning() << "Build failed:" << buildProc.readAllStandardError();
        emit reloadCompleted(false);
        return false;
    }
    
    qDebug() << "Build successful";
    
    // Step 2: Spawn new process
    QString newBin = QDir::current().absoluteFilePath("build/bin/Release/RawrXD-QtShell.exe");
    QStringList args = QCoreApplication::arguments();
    args.removeFirst(); // Remove program name
    
    qint64 pid;
    if (!QProcess::startDetached(newBin, args, QDir::currentPath(), &pid)) {
        qWarning() << "Failed to start new process";
        emit reloadCompleted(false);
        return false;
    }
    
    qDebug() << "New process started with PID" << pid;
    
    // Step 3: Suicide after 500ms (let new process take over sockets/resources)
    QTimer::singleShot(500, qApp, [this]() {
        qDebug() << "Exiting old process for hot-reload";
        emit reloadCompleted(true);
        QCoreApplication::quit();
    });
    
    return true;
}

bool SelfPatch::patchFile(const QString& filename, const QString& patch) {
    QFile file(filename);
    if (!file.open(QIODevice::ReadWrite | QIODevice::Text)) {
        qWarning() << "Failed to open file for patching:" << filename;
        return false;
    }
    
    QString content = QString::fromUtf8(file.readAll());
    
    // Simple patch application (append or replace)
    if (patch.startsWith("APPEND:")) {
        content += patch.mid(7);
    } else if (patch.startsWith("REPLACE:")) {
        // Format: REPLACE:oldText->newText
        QStringList parts = patch.mid(8).split("->");
        if (parts.size() == 2) {
            content.replace(parts[0], parts[1]);
        }
    } else {
        // Default: append
        content += "\n" + patch;
    }
    
    file.seek(0);
    file.write(content.toUtf8());
    file.resize(file.pos());
    file.close();
    
    qDebug() << "Patched file:" << filename;
    return true;
}
