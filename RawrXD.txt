<#
.SYNOPSIS
    RawrXD - AI-Powered Text Editor with Ollama Integration
.DESCRIPTION
    A comprehensive 3-pane text editor featuring:
    - File Explorer with syntax highlighting
    - AI Chat integration via Ollama
    - Embedded web browser (WebView2/IE fallback)
    - Integrated terminal
    - Git version control
    - Agent task automation
    - Extension marketplace
.NOTES
    Author: PowerShield Team
    Version: 2.0
    Requires: PowerShell 5.1+, Ollama (optional)
#>

#Requires -Version 5.1

# Strict mode for better error detection
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Global error handler
trap {
    Write-StartupLog "CRITICAL ERROR: $_" "ERROR"
    Write-StartupLog "Stack Trace: $($_.ScriptStackTrace)" "ERROR"
    continue
}

Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing
Add-Type -AssemblyName System.Net.Http
Add-Type -AssemblyName System.IO.Compression.FileSystem
Add-Type -AssemblyName Microsoft.VisualBasic

# Set application compatibility settings BEFORE creating any Windows Forms objects
[System.Windows.Forms.Application]::EnableVisualStyles()
[System.Windows.Forms.Application]::SetCompatibleTextRenderingDefault($false)

# ============================================
# STARTUP LOGGER SYSTEM
# ============================================
# Create startup log file path
$script:startupLogPath = Join-Path $env:APPDATA "RawrXD\startup.log"
$script:startupLogDir = Split-Path $script:startupLogPath
if (-not (Test-Path $script:startupLogDir)) {
    New-Item -ItemType Directory -Path $script:startupLogDir -Force | Out-Null
}

# Startup logger function - for use before UI is created
function Write-StartupLog {
    param(
        [string]$Message,
        [string]$Level = "INFO"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
    $logEntry = "[$timestamp] [$Level] $Message"
    
    # Write to log file
    try {
        Add-Content -Path $script:startupLogPath -Value $logEntry -Encoding UTF8 -ErrorAction SilentlyContinue
    }
    catch {
        # If log file write fails, continue silently
    }
    
    # Also output to console for immediate feedback during startup
    $color = switch ($Level) {
        "ERROR" { "Red" }
        "WARNING" { "Yellow" }
        "SUCCESS" { "Green" }
        "INFO" { "Cyan" }
        default { "White" }
    }
    Write-Host $logEntry -ForegroundColor $color
}

# Initialize startup log
$startupTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
Write-StartupLog "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" "INFO"
Write-StartupLog "RawrXD Application Startup - Session: $startupTime" "INFO"
Write-StartupLog "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" "INFO"
Write-StartupLog "PowerShell Version: $($PSVersionTable.PSVersion)" "INFO"
Write-StartupLog "Operating System: $([System.Environment]::OSVersion)" "INFO"
Write-StartupLog "Process ID: $PID" "INFO"
Write-StartupLog "User: $env:USERNAME on $env:COMPUTERNAME" "INFO"
Write-StartupLog "Startup Log: $script:startupLogPath" "INFO"

# WebView2 Setup (Modern browser engine for YouTube support)
# Use lightweight WebView2 Runtime instead of full Edge browser
$wvDir = "$env:TEMP\WVLibs"
$script:useWebView2 = $false
$script:browserType = "Unknown"

Write-StartupLog "Checking WebView2 Runtime..." "INFO"

# Check if WebView2 Runtime is already installed system-wide
$webView2Installed = Test-Path "HKLM:\SOFTWARE\WOW6432Node\Microsoft\EdgeUpdate\Clients\{F3017226-FE2A-4295-8BDF-00C3A9A7E4C5}"

if ($webView2Installed) {
    Write-StartupLog "WebView2 Runtime already installed" "SUCCESS"
}
else {
    Write-StartupLog "WebView2 Runtime not found, downloading portable version..." "WARNING"
    
    if (!(Test-Path "$wvDir")) {
        try {
            New-Item -ItemType Directory -Path "$wvDir" -Force | Out-Null
            
            # Download WebView2 NuGet package (no admin required)
            Write-StartupLog "Downloading WebView2 libraries (portable, no admin needed)..." "INFO"
            Invoke-WebRequest "https://www.nuget.org/api/v2/package/Microsoft.Web.WebView2" -OutFile "$wvDir\wv.zip" -ErrorAction Stop
            
            Add-Type -AssemblyName System.IO.Compression.FileSystem
            [IO.Compression.ZipFile]::ExtractToDirectory("$wvDir\wv.zip", "$wvDir\ex", $true)
            
            # Find and copy the WinForms DLL (managed assembly)
            $winformsDll = Get-ChildItem "$wvDir\ex" -Recurse -Filter "Microsoft.Web.WebView2.WinForms.dll" | 
            Where-Object { $_.FullName -match "net45" } | 
            Select-Object -First 1
            
            if ($winformsDll) {
                Copy-Item $winformsDll.FullName -Destination $wvDir -Force
                Write-Host "‚úì WebView2 libraries installed (portable mode)" -ForegroundColor Green
            }
        }
        catch {
            Write-Host "‚ö† Could not download WebView2. Using Internet Explorer fallback for browser." -ForegroundColor Yellow
            Write-Host "  (YouTube may not work in IE fallback mode)" -ForegroundColor DarkYellow
        }
    }
}

# Try to load the managed WinForms assembly
if (Test-Path "$wvDir\Microsoft.Web.WebView2.WinForms.dll") {
    try {
        Add-Type -Path "$wvDir\Microsoft.Web.WebView2.WinForms.dll" -ErrorAction Stop
        $script:useWebView2 = $true
        Write-Host "‚úì WebView2 loaded successfully (YouTube ready!)" -ForegroundColor Green
    }
    catch {
        Write-Host "‚ö† WebView2 load failed: $($_.Exception.Message)" -ForegroundColor Yellow
        Write-Host "  Using Internet Explorer fallback" -ForegroundColor DarkYellow
        $script:useWebView2 = $false
    }
}
else {
    Write-Host "‚ö† WebView2 not available, using Internet Explorer fallback" -ForegroundColor Yellow
    Write-Host "  (YouTube embeds may not work in IE mode)" -ForegroundColor DarkYellow
    $script:useWebView2 = $false
}

# Configuration (Adjust these as needed)
$OllamaAPIEndpoint = "http://localhost:11434/api/generate"  # API Endpoint
$OllamaModel = "bigdaddyg-fast:latest" # Default Ollama Model

# GUI Setup
$form = New-Object System.Windows.Forms.Form
$form.Text = "AI Text Editor - 3 Pane"
$form.Size = New-Object System.Drawing.Size(1200, 700)
$form.StartPosition = "CenterScreen"

# Main vertical splitter (Left: Explorer+Editor, Right: Chat)
$mainSplitter = New-Object System.Windows.Forms.SplitContainer
$mainSplitter.Dock = [System.Windows.Forms.DockStyle]::Fill
$mainSplitter.Orientation = [System.Windows.Forms.Orientation]::Vertical
$mainSplitter.SplitterDistance = 800

# Left side splitter (Explorer and Editor)
$leftSplitter = New-Object System.Windows.Forms.SplitContainer
$leftSplitter.Dock = [System.Windows.Forms.DockStyle]::Fill
$leftSplitter.Orientation = [System.Windows.Forms.Orientation]::Vertical
$leftSplitter.SplitterDistance = 200
$mainSplitter.Panel1.Controls.Add($leftSplitter) | Out-Null

# File Explorer Container (Left Pane)
$explorerContainer = New-Object System.Windows.Forms.Panel
$explorerContainer.Dock = [System.Windows.Forms.DockStyle]::Fill
$leftSplitter.Panel1.Controls.Add($explorerContainer) | Out-Null

# File Explorer (TreeView) - Add FIRST so it fills remaining space
$explorer = New-Object System.Windows.Forms.TreeView
$explorer.Dock = [System.Windows.Forms.DockStyle]::Fill
$explorer.ShowLines = $true
$explorer.ShowRootLines = $true
$explorer.Font = New-Object System.Drawing.Font("Consolas", 9)
$explorer.BorderStyle = [System.Windows.Forms.BorderStyle]::None
$explorerContainer.Controls.Add($explorer) | Out-Null

# Explorer toolbar - Add SECOND so it docks on top
$explorerToolbar = New-Object System.Windows.Forms.Panel
$explorerToolbar.Dock = [System.Windows.Forms.DockStyle]::Top
$explorerToolbar.Height = 30
$explorerToolbar.BackColor = [System.Drawing.Color]::FromArgb(45, 45, 45)
$explorerContainer.Controls.Add($explorerToolbar) | Out-Null

# Explorer refresh button
$explorerRefreshBtn = New-Object System.Windows.Forms.Button
$explorerRefreshBtn.Text = "üîÑ"
$explorerRefreshBtn.Dock = [System.Windows.Forms.DockStyle]::Right
$explorerRefreshBtn.Width = 30
$explorerRefreshBtn.FlatStyle = [System.Windows.Forms.FlatStyle]::Flat
$explorerRefreshBtn.BackColor = [System.Drawing.Color]::FromArgb(60, 60, 60)
$explorerRefreshBtn.ForeColor = [System.Drawing.Color]::White
$explorerRefreshBtn.Font = New-Object System.Drawing.Font("Segoe UI", 10)
$explorerToolbar.Controls.Add($explorerRefreshBtn) | Out-Null

# Explorer up/back button
$explorerUpBtn = New-Object System.Windows.Forms.Button
$explorerUpBtn.Text = "‚¨ÜÔ∏è"
$explorerUpBtn.Dock = [System.Windows.Forms.DockStyle]::Right
$explorerUpBtn.Width = 30
$explorerUpBtn.FlatStyle = [System.Windows.Forms.FlatStyle]::Flat
$explorerUpBtn.BackColor = [System.Drawing.Color]::FromArgb(60, 60, 60)
$explorerUpBtn.ForeColor = [System.Drawing.Color]::White
$explorerUpBtn.Font = New-Object System.Drawing.Font("Segoe UI", 10)
$explorerToolbar.Controls.Add($explorerUpBtn) | Out-Null

# Current path label
$explorerPathLabel = New-Object System.Windows.Forms.Label
$explorerPathLabel.Text = "Path: "
$explorerPathLabel.Dock = [System.Windows.Forms.DockStyle]::Fill
$explorerPathLabel.Font = New-Object System.Drawing.Font("Segoe UI", 8)
$explorerPathLabel.ForeColor = [System.Drawing.Color]::White
$explorerPathLabel.Padding = New-Object System.Windows.Forms.Padding(5, 8, 5, 0)
$explorerToolbar.Controls.Add($explorerPathLabel) | Out-Null

# Text Editor (Middle Pane)
$editor = New-Object System.Windows.Forms.RichTextBox
$editor.Dock = [System.Windows.Forms.DockStyle]::Fill
$editor.Font = New-Object System.Drawing.Font("Consolas", 10)
$leftSplitter.Panel2.Controls.Add($editor) | Out-Null

# Right side - Tab Control for Chat and Browser
$rightTabControl = New-Object System.Windows.Forms.TabControl
$rightTabControl.Dock = [System.Windows.Forms.DockStyle]::Fill
$mainSplitter.Panel2.Controls.Add($rightTabControl) | Out-Null

# Chat Tab
$chatTab = New-Object System.Windows.Forms.TabPage
$chatTab.Text = "Chat"
$rightTabControl.TabPages.Add($chatTab) | Out-Null

# Chat area splitter
$chatSplitter = New-Object System.Windows.Forms.SplitContainer
$chatSplitter.Dock = [System.Windows.Forms.DockStyle]::Fill
$chatSplitter.Orientation = [System.Windows.Forms.Orientation]::Horizontal
$chatSplitter.SplitterDistance = 400
$chatTab.Controls.Add($chatSplitter) | Out-Null

# Chat Box
$chatBox = New-Object System.Windows.Forms.RichTextBox
$chatBox.Dock = [System.Windows.Forms.DockStyle]::Fill
$chatBox.ReadOnly = $false
$chatBox.Font = New-Object System.Drawing.Font("Segoe UI", 9)
$chatSplitter.Panel1.Controls.Add($chatBox) | Out-Null

# Input Box Container
$inputContainer = New-Object System.Windows.Forms.Panel
$inputContainer.Dock = [System.Windows.Forms.DockStyle]::Fill
$inputContainer.Height = 50
$chatSplitter.Panel2.Controls.Add($inputContainer) | Out-Null

# Input Box
$inputBox = New-Object System.Windows.Forms.TextBox
$inputBox.Dock = [System.Windows.Forms.DockStyle]::Fill
$inputBox.Multiline = $true
$inputBox.Font = New-Object System.Drawing.Font("Segoe UI", 9)
$inputContainer.Controls.Add($inputBox) | Out-Null

# Git Tab
$gitTab = New-Object System.Windows.Forms.TabPage
$gitTab.Text = "Git"
$rightTabControl.TabPages.Add($gitTab) | Out-Null

# Git container
$gitContainer = New-Object System.Windows.Forms.Panel
$gitContainer.Dock = [System.Windows.Forms.DockStyle]::Fill
$gitTab.Controls.Add($gitContainer) | Out-Null

# Git toolbar
$gitToolbar = New-Object System.Windows.Forms.Panel
$gitToolbar.Dock = [System.Windows.Forms.DockStyle]::Top
$gitToolbar.Height = 40
$gitContainer.Controls.Add($gitToolbar) | Out-Null

# Git status refresh button
$gitRefreshBtn = New-Object System.Windows.Forms.Button
$gitRefreshBtn.Text = "Refresh"
$gitRefreshBtn.Dock = [System.Windows.Forms.DockStyle]::Left
$gitRefreshBtn.Width = 80
$gitToolbar.Controls.Add($gitRefreshBtn) | Out-Null

# Git status label
$gitStatusLabel = New-Object System.Windows.Forms.Label
$gitStatusLabel.Text = "Git Status"
$gitStatusLabel.Dock = [System.Windows.Forms.DockStyle]::Fill
$gitStatusLabel.Font = New-Object System.Drawing.Font("Segoe UI", 9, [System.Drawing.FontStyle]::Bold)
$gitToolbar.Controls.Add($gitStatusLabel) | Out-Null

# Git status display
$gitStatusBox = New-Object System.Windows.Forms.RichTextBox
$gitStatusBox.Dock = [System.Windows.Forms.DockStyle]::Fill
$gitStatusBox.ReadOnly = $false
$gitStatusBox.Font = New-Object System.Drawing.Font("Consolas", 9)
$gitStatusBox.BackColor = [System.Drawing.Color]::FromArgb(30, 30, 30)
$gitStatusBox.ForeColor = [System.Drawing.Color]::FromArgb(200, 200, 200)
$gitContainer.Controls.Add($gitStatusBox) | Out-Null

# Agent Tasks Tab (for Copilot-style workflows)
$agentTasksTab = New-Object System.Windows.Forms.TabPage
$agentTasksTab.Text = "Agent Tasks"
$rightTabControl.TabPages.Add($agentTasksTab) | Out-Null

# Agent tasks container
$agentTasksContainer = New-Object System.Windows.Forms.Panel
$agentTasksContainer.Dock = [System.Windows.Forms.DockStyle]::Fill
$agentTasksTab.Controls.Add($agentTasksContainer) | Out-Null

# Agent tasks toolbar
$agentTasksToolbar = New-Object System.Windows.Forms.Panel
$agentTasksToolbar.Dock = [System.Windows.Forms.DockStyle]::Top
$agentTasksToolbar.Height = 40
$agentTasksContainer.Controls.Add($agentTasksToolbar) | Out-Null

# Agent status label
$agentStatusLabel = New-Object System.Windows.Forms.Label
$agentStatusLabel.Text = "Agent Status: Active - Agentic editing enabled"
$agentStatusLabel.Dock = [System.Windows.Forms.DockStyle]::Fill
$agentStatusLabel.Font = New-Object System.Drawing.Font("Segoe UI", 9, [System.Drawing.FontStyle]::Bold)
$agentStatusLabel.ForeColor = 'Green'
$agentTasksToolbar.Controls.Add($agentStatusLabel) | Out-Null

# Ollama status label and controls
$ollamaToolbar = New-Object System.Windows.Forms.Panel
$ollamaToolbar.Dock = [System.Windows.Forms.DockStyle]::Top
$ollamaToolbar.Height = 30
$agentTasksContainer.Controls.Add($ollamaToolbar) | Out-Null

$script:ollamaStatusLabel = New-Object System.Windows.Forms.Label
$script:ollamaStatusLabel.Text = "üî¥ Ollama: Initializing..."
$script:ollamaStatusLabel.Dock = [System.Windows.Forms.DockStyle]::Left
$script:ollamaStatusLabel.Width = 200
$script:ollamaStatusLabel.Font = New-Object System.Drawing.Font("Segoe UI", 9, [System.Drawing.FontStyle]::Bold)
$script:ollamaStatusLabel.ForeColor = 'Orange'
$script:ollamaStatusLabel.TextAlign = [System.Drawing.ContentAlignment]::MiddleLeft
$ollamaToolbar.Controls.Add($script:ollamaStatusLabel) | Out-Null

$ollamaStartBtn = New-Object System.Windows.Forms.Button
$ollamaStartBtn.Text = "Start"
$ollamaStartBtn.Size = New-Object System.Drawing.Size(50, 25)
$ollamaStartBtn.Dock = [System.Windows.Forms.DockStyle]::Left
$ollamaStartBtn.Add_Click({
        Start-OllamaServer
        Update-OllamaStatusDisplay
    })
$ollamaToolbar.Controls.Add($ollamaStartBtn) | Out-Null

$ollamaStopBtn = New-Object System.Windows.Forms.Button
$ollamaStopBtn.Text = "Stop"
$ollamaStopBtn.Size = New-Object System.Drawing.Size(50, 25)
$ollamaStopBtn.Dock = [System.Windows.Forms.DockStyle]::Left
$ollamaStopBtn.Add_Click({
        Stop-OllamaServer
        Update-OllamaStatusDisplay
    })
$ollamaToolbar.Controls.Add($ollamaStopBtn) | Out-Null

$ollamaRefreshBtn = New-Object System.Windows.Forms.Button
$ollamaRefreshBtn.Text = "Refresh"
$ollamaRefreshBtn.Size = New-Object System.Drawing.Size(60, 25)
$ollamaRefreshBtn.Dock = [System.Windows.Forms.DockStyle]::Left
$ollamaRefreshBtn.Add_Click({
        # Check current status
        $status = Get-OllamaStatus
        Write-DevConsole "Ollama Status Check: $($status | ConvertTo-Json -Compress)" "INFO"
        Update-OllamaStatusDisplay
    })
$ollamaToolbar.Controls.Add($ollamaRefreshBtn) | Out-Null

# Agent tasks list
$agentTasksList = New-Object System.Windows.Forms.ListView
$agentTasksList.Dock = [System.Windows.Forms.DockStyle]::Fill
$agentTasksList.View = [System.Windows.Forms.View]::Details
$agentTasksList.FullRowSelect = $true
$agentTasksList.Columns.Add("Task", 200) | Out-Null
$agentTasksList.Columns.Add("Status", 100) | Out-Null
$agentTasksList.Columns.Add("Progress", 150) | Out-Null
$agentTasksList.Columns.Add("Time", 100) | Out-Null
$agentTasksList.Add_SelectedIndexChanged({
        if ($agentTasksList.SelectedItems.Count -gt 0) {
            $taskId = $agentTasksList.SelectedItems[0].Tag
            $task = $global:agentContext.Tasks | Where-Object { $_.Id -eq $taskId } | Select-Object -First 1
            if ($task) {
                $agentTaskDetails.Clear()
                $agentTaskDetails.AppendText("Task: $($task.Name)`r`n")
                $agentTaskDetails.AppendText("Status: $($task.Status)`r`n")
                $agentTaskDetails.AppendText("Steps:`r`n")
                foreach ($step in $task.Steps) {
                    $status = if ($step.Completed) { "‚úì" } else { "‚óã" }
                    $agentTaskDetails.AppendText("  $status $($step.Description)`r`n")
                }
            }
        }
    })
$agentTasksContainer.Controls.Add($agentTasksList) | Out-Null

# Agent task details panel
$agentTaskDetails = New-Object System.Windows.Forms.RichTextBox
$agentTaskDetails.Dock = [System.Windows.Forms.DockStyle]::Fill
$agentTaskDetails.ReadOnly = $true
$agentTaskDetails.Font = New-Object System.Drawing.Font("Consolas", 8)
$agentTaskDetails.BackColor = [System.Drawing.Color]::FromArgb(20, 20, 20)
$agentTaskDetails.ForeColor = [System.Drawing.Color]::FromArgb(200, 200, 200)
$agentTaskDetails.Text = "Agent Task Console - Use the input below to send commands to the agent`r`n"
$agentTasksContainer.Controls.Add($agentTaskDetails) | Out-Null

# Agent input container
$agentInputContainer = New-Object System.Windows.Forms.Panel
$agentInputContainer.Dock = [System.Windows.Forms.DockStyle]::Bottom
$agentInputContainer.Height = 60
$agentInputContainer.BackColor = [System.Drawing.Color]::FromArgb(30, 30, 30)
$agentTasksContainer.Controls.Add($agentInputContainer) | Out-Null

# Agent input label
$agentInputLabel = New-Object System.Windows.Forms.Label
$agentInputLabel.Text = "Agent Command:"
$agentInputLabel.Location = New-Object System.Drawing.Point(10, 8)
$agentInputLabel.Size = New-Object System.Drawing.Size(100, 20)
$agentInputLabel.ForeColor = [System.Drawing.Color]::White
$agentInputLabel.Font = New-Object System.Drawing.Font("Segoe UI", 9)
$agentInputContainer.Controls.Add($agentInputLabel) | Out-Null

# Agent input textbox
$agentInputBox = New-Object System.Windows.Forms.TextBox
$agentInputBox.Location = New-Object System.Drawing.Point(10, 30)
$agentInputBox.Anchor = ([System.Windows.Forms.AnchorStyles]::Top -bor [System.Windows.Forms.AnchorStyles]::Left -bor [System.Windows.Forms.AnchorStyles]::Right)
$agentInputBox.Size = New-Object System.Drawing.Size(280, 25)
$agentInputBox.Font = New-Object System.Drawing.Font("Consolas", 9)
$agentInputBox.BackColor = [System.Drawing.Color]::FromArgb(40, 40, 40)
$agentInputBox.ForeColor = [System.Drawing.Color]::White
$agentInputContainer.Controls.Add($agentInputBox) | Out-Null

# Agent send button
$agentSendBtn = New-Object System.Windows.Forms.Button
$agentSendBtn.Text = "Send"
$agentSendBtn.Location = New-Object System.Drawing.Point(300, 30)
$agentSendBtn.Anchor = [System.Windows.Forms.AnchorStyles]::Top -bor [System.Windows.Forms.AnchorStyles]::Right
$agentSendBtn.Size = New-Object System.Drawing.Size(60, 25)
$agentSendBtn.BackColor = [System.Drawing.Color]::FromArgb(0, 120, 215)
$agentSendBtn.ForeColor = [System.Drawing.Color]::White
$agentSendBtn.FlatStyle = [System.Windows.Forms.FlatStyle]::Flat
$agentInputContainer.Controls.Add($agentSendBtn) | Out-Null

# Terminal Tab
$terminalTab = New-Object System.Windows.Forms.TabPage
$terminalTab.Text = "Terminal"
$rightTabControl.TabPages.Add($terminalTab) | Out-Null

# Terminal container
$terminalContainer = New-Object System.Windows.Forms.Panel
$terminalContainer.Dock = [System.Windows.Forms.DockStyle]::Fill
$terminalTab.Controls.Add($terminalContainer) | Out-Null

# Terminal output
$terminalOutput = New-Object System.Windows.Forms.RichTextBox
$terminalOutput.Dock = [System.Windows.Forms.DockStyle]::Fill
$terminalOutput.ReadOnly = $false
$terminalOutput.Font = New-Object System.Drawing.Font("Consolas", 9)
$terminalOutput.BackColor = [System.Drawing.Color]::FromArgb(0, 0, 0)
$terminalOutput.ForeColor = [System.Drawing.Color]::FromArgb(0, 255, 0)
$terminalContainer.Controls.Add($terminalOutput) | Out-Null

# Terminal input container
$terminalInputContainer = New-Object System.Windows.Forms.Panel
$terminalInputContainer.Dock = [System.Windows.Forms.DockStyle]::Bottom
$terminalInputContainer.Height = 30
$terminalContainer.Controls.Add($terminalInputContainer) | Out-Null

# Terminal prompt
$terminalPrompt = New-Object System.Windows.Forms.Label
$terminalPrompt.Text = "PS> "
$terminalPrompt.Dock = [System.Windows.Forms.DockStyle]::Left
$terminalPrompt.Width = 40
$terminalPrompt.Font = New-Object System.Drawing.Font("Consolas", 9)
$terminalPrompt.ForeColor = [System.Drawing.Color]::FromArgb(0, 255, 0)
$terminalInputContainer.Controls.Add($terminalPrompt) | Out-Null

# Terminal input
$terminalInput = New-Object System.Windows.Forms.TextBox
$terminalInput.Dock = [System.Windows.Forms.DockStyle]::Fill
$terminalInput.Font = New-Object System.Drawing.Font("Consolas", 9)
$terminalInput.BackColor = [System.Drawing.Color]::FromArgb(0, 0, 0)
$terminalInput.ForeColor = [System.Drawing.Color]::FromArgb(0, 255, 0)
$terminalInputContainer.Controls.Add($terminalInput) | Out-Null

# Global variables
$global:currentWorkingDir = Get-Location
$global:terminalHistory = @()
$global:terminalHistoryIndex = -1
$global:currentFile = $null

# Ollama Server Management
$global:ollamaProcess = $null
$global:ollamaStartupAttempted = $false
$global:ollamaServerStatus = "Stopped"
$script:ollamaTimer = $null

# Settings & Configuration
$global:settings = @{
    OllamaModel      = $OllamaModel
    MaxTabs          = 25
    EditorFontSize   = 10
    EditorFontFamily = "Consolas"
    AutoSaveEnabled  = $true
    AutoSaveInterval = 30  # seconds
    ThemeMode        = "Dark"
    ShowLineNumbers  = $true
    CodeHighlighting = $true
    AutoIndent       = $true
    TabSize          = 4
    WrapText         = $false
    ShowWhitespace   = $false
    AutoComplete     = $true
    DebugMode        = $false
    MaxChatTabs      = 5
    ChatTabAutoClose = $false
    ChatTabPosition  = "Right" # Right, Bottom, Popup
}

# Settings file path
$script:settingsPath = Join-Path $env:APPDATA "RawrXD\settings.json"

# Agentic System State
$global:agentContext = @{
    SessionId       = [guid]::NewGuid().ToString()
    StartTime       = Get-Date
    Messages        = @()
    Edits           = @()
    Commands        = @()
    Tasks           = @()
    Environment     = @{}
    DependencyGraph = @{}
    PendingEdits    = @()
    Logs            = @()
}

# Chat History Persistence
$script:chatHistoryPath = Join-Path $env:APPDATA "RawrXD\chat_history.txt"
$script:chatHistoryDir = Split-Path $script:chatHistoryPath
if (-not (Test-Path $script:chatHistoryDir)) {
    New-Item -ItemType Directory -Path $script:chatHistoryDir -Force | Out-Null
}

# Extension Marketplace System
$script:extensionsDir = Join-Path $env:APPDATA "RawrXD\Extensions"
if (-not (Test-Path $script:extensionsDir)) {
    New-Item -ItemType Directory -Path $script:extensionsDir -Force | Out-Null
}

$script:extensionRegistry = @()
$script:marketplaceCache = @()

# Agent Tools System
$script:agentTools = @{}

# Extension Capabilities
$script:CAP_SYNTAX_HIGHLIGHT = 1
$script:CAP_CODE_COMPLETION = 2
$script:CAP_DEBUGGING = 4
$script:CAP_LINTING = 8
$script:CAP_FORMATTING = 16
$script:CAP_REFACTORING = 32
$script:CAP_BUILD_SYSTEM = 64
$script:CAP_GIT_INTEGRATION = 128
$script:CAP_MODEL_DAMPENING = 256
$script:CAP_AI_ASSIST = 512

# Language IDs
$script:LANG_ASM = 0
$script:LANG_PYTHON = 1
$script:LANG_C = 2
$script:LANG_CPP = 3
$script:LANG_RUST = 4
$script:LANG_GO = 5
$script:LANG_JAVASCRIPT = 6
$script:LANG_CUSTOM = 999

# Browser Tab
$browserTab = New-Object System.Windows.Forms.TabPage
$browserTab.Text = "Browser"
$rightTabControl.TabPages.Add($browserTab) | Out-Null

# Browser container with controls
$browserContainer = New-Object System.Windows.Forms.Panel
$browserContainer.Dock = [System.Windows.Forms.DockStyle]::Fill
$browserTab.Controls.Add($browserContainer) | Out-Null

# Browser toolbar
$browserToolbar = New-Object System.Windows.Forms.Panel
$browserToolbar.Dock = [System.Windows.Forms.DockStyle]::Top
$browserToolbar.Height = 40
$browserContainer.Controls.Add($browserToolbar) | Out-Null

# Browser URL box
$browserUrlBox = New-Object System.Windows.Forms.TextBox
$browserUrlBox.Dock = [System.Windows.Forms.DockStyle]::Fill
$browserUrlBox.Font = New-Object System.Drawing.Font("Segoe UI", 9)
$browserUrlBox.Text = "https://www.youtube.com"
$browserToolbar.Controls.Add($browserUrlBox) | Out-Null

# Browser buttons panel
$browserButtons = New-Object System.Windows.Forms.Panel
$browserButtons.Dock = [System.Windows.Forms.DockStyle]::Right
$browserButtons.Width = 200
$browserToolbar.Controls.Add($browserButtons) | Out-Null

# Go button
$browserGoBtn = New-Object System.Windows.Forms.Button
$browserGoBtn.Text = "Go"
$browserGoBtn.Dock = [System.Windows.Forms.DockStyle]::Left
$browserGoBtn.Width = 50
$browserButtons.Controls.Add($browserGoBtn) | Out-Null

# Back button
$browserBackBtn = New-Object System.Windows.Forms.Button
$browserBackBtn.Text = "‚Üê"
$browserBackBtn.Dock = [System.Windows.Forms.DockStyle]::Left
$browserBackBtn.Width = 40
$browserButtons.Controls.Add($browserBackBtn) | Out-Null

# Forward button
$browserForwardBtn = New-Object System.Windows.Forms.Button
$browserForwardBtn.Text = "‚Üí"
$browserForwardBtn.Dock = [System.Windows.Forms.DockStyle]::Left
$browserForwardBtn.Width = 40
$browserButtons.Controls.Add($browserForwardBtn) | Out-Null

# Refresh button
$browserRefreshBtn = New-Object System.Windows.Forms.Button
$browserRefreshBtn.Text = "‚Üª"
$browserRefreshBtn.Dock = [System.Windows.Forms.DockStyle]::Left
$browserRefreshBtn.Width = 40
$browserButtons.Controls.Add($browserRefreshBtn) | Out-Null

# WebBrowser control (WebView2 or fallback)
if ($script:useWebView2) {
    try {
        Write-DevConsole "Initializing WebView2 browser..." "INFO"
        $webBrowser = New-Object Microsoft.Web.WebView2.WinForms.WebView2
        $webBrowser.Dock = [System.Windows.Forms.DockStyle]::Fill
        $browserContainer.Controls.Add($webBrowser) | Out-Null
        
        # Initialize WebView2 with proper error handling
        $webBrowser.CoreWebView2InitializationCompleted.Add({
                param($sender, $args)
                if ($args.IsSuccess) {
                    Write-DevConsole "WebView2 initialization successful" "SUCCESS"
                    
                    # Add host object for agentic control
                    $webBrowser.CoreWebView2.AddHostObjectToScript("rawrAgent", @{
                            getPageTitle  = {
                                return $webBrowser.CoreWebView2.DocumentTitle
                            }
                            getPageUrl    = {
                                return $webBrowser.CoreWebView2.Source.ToString()
                            }
                            executeScript = {
                                param($script)
                                return $webBrowser.CoreWebView2.ExecuteScriptAsync($script).Result
                            }
                        })
                    
                    # Set up navigation events
                    $webBrowser.CoreWebView2.Add_NavigationStarting({
                            param($sender, $navArgs)
                            Write-DevConsole "Navigating to: $($navArgs.Uri)" "INFO"
                        })
                    
                    $webBrowser.CoreWebView2.Add_NavigationCompleted({
                            param($sender, $navArgs)
                            if ($navArgs.IsSuccess) {
                                Write-DevConsole "Navigation completed successfully" "SUCCESS"
                                $browserUrlBox.Text = $webBrowser.CoreWebView2.Source.ToString()
                            }
                            else {
                                Write-DevConsole "Navigation failed" "ERROR"
                            }
                        })
                }
                else {
                    Write-DevConsole "WebView2 initialization failed: $($args.InitializationException)" "ERROR"
                    $script:useWebView2 = $false
                }
            })
        
        # Initialize WebView2 asynchronously
        $webBrowser.EnsureCoreWebView2Async() | Out-Null
        $script:browserType = "WebView2"
        
    }
    catch {
        Write-DevConsole "WebView2 initialization failed: $_" "ERROR"
        $script:useWebView2 = $false
        $script:browserType = "WebBrowser"
    }
}

if (-not $script:useWebView2) {
    # Fallback to old WebBrowser control
    Write-DevConsole "Using fallback WebBrowser control" "WARNING"
    $webBrowser = New-Object System.Windows.Forms.WebBrowser
    $webBrowser.Dock = [System.Windows.Forms.DockStyle]::Fill
    $webBrowser.ScriptErrorsSuppressed = $true
    $webBrowser.IsWebBrowserContextMenuEnabled = $true
    $webBrowser.AllowNavigation = $true
    
    # Add navigation events for legacy browser
    $webBrowser.Add_Navigated({
            param($sender, $args)
            $browserUrlBox.Text = $args.Url.ToString()
            Write-DevConsole "Legacy browser navigated to: $($args.Url)" "INFO"
        })
    
    $browserContainer.Controls.Add($webBrowser) | Out-Null
    $script:browserType = "WebBrowser"
}

# ============================================
# DEV TOOLS TAB
# ============================================
$devToolsTab = New-Object System.Windows.Forms.TabPage
$devToolsTab.Text = "Dev Tools"
$rightTabControl.TabPages.Add($devToolsTab) | Out-Null

# Dev Tools container
$devToolsContainer = New-Object System.Windows.Forms.Panel
$devToolsContainer.Dock = [System.Windows.Forms.DockStyle]::Fill
$devToolsTab.Controls.Add($devToolsContainer) | Out-Null

# Dev Tools toolbar
$devToolbar = New-Object System.Windows.Forms.Panel
$devToolbar.Dock = [System.Windows.Forms.DockStyle]::Top
$devToolbar.Height = 40
$devToolbar.BackColor = [System.Drawing.Color]::FromArgb(40, 40, 40)
$devToolsContainer.Controls.Add($devToolbar) | Out-Null

# Clear console button
$clearConsoleBtn = New-Object System.Windows.Forms.Button
$clearConsoleBtn.Text = "Clear Console"
$clearConsoleBtn.Dock = [System.Windows.Forms.DockStyle]::Left
$clearConsoleBtn.Width = 120
$clearConsoleBtn.BackColor = [System.Drawing.Color]::FromArgb(60, 60, 60)
$clearConsoleBtn.ForeColor = [System.Drawing.Color]::White
$devToolbar.Controls.Add($clearConsoleBtn) | Out-Null

# Export log button
$exportLogBtn = New-Object System.Windows.Forms.Button
$exportLogBtn.Text = "Export Log"
$exportLogBtn.Dock = [System.Windows.Forms.DockStyle]::Left
$exportLogBtn.Width = 100
$exportLogBtn.BackColor = [System.Drawing.Color]::FromArgb(60, 60, 60)
$exportLogBtn.ForeColor = [System.Drawing.Color]::White
$devToolbar.Controls.Add($exportLogBtn) | Out-Null

# Console output
$global:devConsole = New-Object System.Windows.Forms.RichTextBox
$global:devConsole.Dock = [System.Windows.Forms.DockStyle]::Fill
$global:devConsole.ReadOnly = $true
$global:devConsole.Font = New-Object System.Drawing.Font("Consolas", 9)
$global:devConsole.BackColor = [System.Drawing.Color]::FromArgb(20, 20, 20)
$global:devConsole.ForeColor = [System.Drawing.Color]::LightGray
$global:devConsole.WordWrap = $false
$devToolsContainer.Controls.Add($global:devConsole) | Out-Null

# Dev Console logging function
function Write-DevConsole {
    param(
        [string]$Message,
        [string]$Level = "INFO"
    )
    
    # Guard clause - if dev console not yet created, output to host instead
    if (-not $global:devConsole) {
        $color = switch ($Level) {
            "ERROR" { "Red" }
            "WARNING" { "Yellow" }
            "SUCCESS" { "Green" }
            "DEBUG" { "Cyan" }
            default { "White" }
        }
        Write-Host "[$Level] $Message" -ForegroundColor $color
        return
    }
    
    $timestamp = Get-Date -Format "HH:mm:ss.fff"
    $color = switch ($Level) {
        "ERROR" { [System.Drawing.Color]::Red }
        "WARNING" { [System.Drawing.Color]::Yellow }
        "SUCCESS" { [System.Drawing.Color]::LightGreen }
        "DEBUG" { [System.Drawing.Color]::Cyan }
        default { [System.Drawing.Color]::LightGray }
    }
    
    $global:devConsole.SelectionStart = $global:devConsole.TextLength
    $global:devConsole.SelectionLength = 0
    $global:devConsole.SelectionColor = [System.Drawing.Color]::DarkGray
    $global:devConsole.AppendText("[$timestamp] ")
    
    $global:devConsole.SelectionColor = $color
    $global:devConsole.AppendText("[$Level] ")
    
    $global:devConsole.SelectionColor = [System.Drawing.Color]::LightGray
    $global:devConsole.AppendText("$Message`r`n")
    
    $global:devConsole.SelectionColor = $global:devConsole.ForeColor
    $global:devConsole.ScrollToCaret()
}

# Clear console button handler
$clearConsoleBtn.Add_Click({
        $global:devConsole.Clear()
        Write-DevConsole "Console cleared" "INFO"
    })

# Export log button handler
$exportLogBtn.Add_Click({
        try {
            $saveDialog = New-Object System.Windows.Forms.SaveFileDialog
            $saveDialog.Filter = "Log Files (*.log)|*.log|Text Files (*.txt)|*.txt"
            $saveDialog.Title = "Export Developer Console Log"
            $saveDialog.FileName = "RawrXD_DevLog_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
            
            if ($saveDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
                [System.IO.File]::WriteAllText($saveDialog.FileName, $global:devConsole.Text)
                Write-DevConsole "‚úÖ Log exported successfully to: $($saveDialog.FileName)" "SUCCESS"
                Write-StartupLog "Log export completed: $($saveDialog.FileName)" "SUCCESS"
            }
        }
        catch {
            Write-DevConsole "Error exporting log: $_" "ERROR"
        }
    })

# Initialize dev console with startup info
Write-DevConsole "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" "INFO"
Write-DevConsole "RawrXD Developer Console Initialized" "SUCCESS"
Write-DevConsole "PowerShell Version: $($PSVersionTable.PSVersion)" "INFO"
Write-DevConsole "Browser Type: $script:browserType" "INFO"
Write-DevConsole "WebView2 Enabled: $script:useWebView2" "INFO"
Write-DevConsole "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" "INFO"

# ============================================
# OLLAMA SERVER MANAGEMENT FUNCTIONS
# ============================================

function Start-OllamaServer {
    [CmdletBinding()]
    param()
    
    try {
        Write-StartupLog "Starting Ollama server..." "INFO"
        Write-DevConsole "Attempting to start Ollama server..." "INFO"
        
        # Check if Ollama is available
        $ollamaPath = Get-Command ollama -ErrorAction SilentlyContinue
        if (-not $ollamaPath) {
            Write-StartupLog "Ollama not found in PATH - install Ollama from ollama.ai" "WARNING"
            Write-DevConsole "Ollama not found in PATH. Please install Ollama from https://ollama.ai" "WARNING"
            $global:ollamaServerStatus = "Not Found"
            return $false
        }
        
        # Check if already running
        $existingProcess = Get-Process -Name "ollama" -ErrorAction SilentlyContinue | Where-Object { $_.MainWindowTitle -eq "" }
        if ($existingProcess) {
            Write-StartupLog "Ollama server already running (PID: $($existingProcess.Id))" "SUCCESS"
            Write-DevConsole "Ollama server already running (PID: $($existingProcess.Id))" "SUCCESS"
            $global:ollamaProcess = $existingProcess
            $global:ollamaServerStatus = "Running"
            return $true
        }
        
        # Start Ollama server
        $processInfo = New-Object System.Diagnostics.ProcessStartInfo
        $processInfo.FileName = "ollama"
        $processInfo.Arguments = "serve"
        $processInfo.UseShellExecute = $false
        $processInfo.CreateNoWindow = $true
        $processInfo.RedirectStandardOutput = $true
        $processInfo.RedirectStandardError = $true
        
        $global:ollamaProcess = [System.Diagnostics.Process]::Start($processInfo)
        
        if ($global:ollamaProcess) {
            Write-StartupLog "Ollama server started successfully (PID: $($global:ollamaProcess.Id))" "SUCCESS"
            Write-DevConsole "‚úì Ollama server started (PID: $($global:ollamaProcess.Id))" "SUCCESS"
            $global:ollamaServerStatus = "Starting"
            
            # Wait for server to initialize
            Start-Sleep -Seconds 3
            
            # Test connection
            if (Test-OllamaConnection) {
                $global:ollamaServerStatus = "Running"
                Write-DevConsole "‚úì Ollama server ready and responding" "SUCCESS"
                return $true
            }
            else {
                $global:ollamaServerStatus = "Failed to Connect"
                Write-DevConsole "‚úó Ollama server started but not responding" "WARNING"
                return $false
            }
        }
        else {
            Write-StartupLog "Failed to start Ollama server" "ERROR"
            Write-DevConsole "‚úó Failed to start Ollama server" "ERROR"
            $global:ollamaServerStatus = "Failed"
            return $false
        }
    }
    catch {
        Write-StartupLog "Error starting Ollama server: $_" "ERROR"
        Write-DevConsole "Error starting Ollama server: $_" "ERROR"
        $global:ollamaServerStatus = "Error"
        return $false
    }
}

function Stop-OllamaServer {
    [CmdletBinding()]
    param()
    
    try {
        Write-DevConsole "Stopping Ollama server..." "INFO"
        
        if ($global:ollamaProcess -and -not $global:ollamaProcess.HasExited) {
            $global:ollamaProcess.Kill()
            $global:ollamaProcess.WaitForExit(5000)  # Wait up to 5 seconds
            Write-DevConsole "‚úì Ollama server stopped" "SUCCESS"
        }
        
        # Also check for any other Ollama processes
        Get-Process -Name "ollama" -ErrorAction SilentlyContinue | ForEach-Object {
            try {
                $_.Kill()
                Write-DevConsole "Stopped additional Ollama process (PID: $($_.Id))" "INFO"
            }
            catch {
                Write-DevConsole "Could not stop Ollama process (PID: $($_.Id)): $_" "WARNING"
            }
        }
        
        $global:ollamaProcess = $null
        $global:ollamaServerStatus = "Stopped"
        return $true
    }
    catch {
        Write-DevConsole "Error stopping Ollama server: $_" "ERROR"
        $global:ollamaServerStatus = "Error"
        return $false
    }
}

function Test-OllamaConnection {
    [CmdletBinding()]
    param(
        [int]$TimeoutSeconds = 5
    )
    
    try {
        $testUrl = "http://localhost:11434/api/tags"
        $request = [System.Net.WebRequest]::Create($testUrl)
        $request.Method = "GET"
        $request.Timeout = $TimeoutSeconds * 1000
        
        $response = $request.GetResponse()
        $statusCode = $response.StatusCode
        $response.Close()
        
        return ($statusCode -eq 200)
    }
    catch {
        return $false
    }
}

function Get-OllamaStatus {
    [CmdletBinding()]
    param()
    
    return @{
        Status     = $global:ollamaServerStatus
        ProcessId  = if ($global:ollamaProcess) { $global:ollamaProcess.Id } else { $null }
        IsRunning  = if ($global:ollamaProcess) { -not $global:ollamaProcess.HasExited } else { $false }
        Connection = Test-OllamaConnection
    }
}

function Update-OllamaStatusDisplay {
    [CmdletBinding()]
    param()
    
    if ($script:ollamaStatusLabel) {
        $status = Get-OllamaStatus
        
        switch ($status.Status) {
            "Running" { 
                $script:ollamaStatusLabel.Text = "üü¢ Ollama: Running"
                $script:ollamaStatusLabel.ForeColor = [System.Drawing.Color]::Green
            }
            "Starting" { 
                $script:ollamaStatusLabel.Text = "üü° Ollama: Starting..."
                $script:ollamaStatusLabel.ForeColor = [System.Drawing.Color]::Orange
            }
            "Stopped" { 
                $script:ollamaStatusLabel.Text = "üî¥ Ollama: Stopped"
                $script:ollamaStatusLabel.ForeColor = [System.Drawing.Color]::Red
            }
            "Not Found" { 
                $script:ollamaStatusLabel.Text = "‚ùå Ollama: Not Installed"
                $script:ollamaStatusLabel.ForeColor = [System.Drawing.Color]::DarkRed
            }
            default { 
                $script:ollamaStatusLabel.Text = "‚ö†Ô∏è Ollama: $($status.Status)"
                $script:ollamaStatusLabel.ForeColor = [System.Drawing.Color]::Orange
            }
        }
    }
}

# Menu
$menu = New-Object System.Windows.Forms.MenuStrip
$menu.Dock = [System.Windows.Forms.DockStyle]::Top
$form.MainMenuStrip = $menu

# File Menu
$fileMenu = New-Object System.Windows.Forms.ToolStripMenuItem "File"
$menu.Items.Add($fileMenu) | Out-Null

$openItem = New-Object System.Windows.Forms.ToolStripMenuItem "Open..."
$saveItem = New-Object System.Windows.Forms.ToolStripMenuItem "Save"
$saveAsItem = New-Object System.Windows.Forms.ToolStripMenuItem "Save As..."
$browseItem = New-Object System.Windows.Forms.ToolStripMenuItem "Browse Folder..."
$fileMenu.DropDownItems.AddRange(@($openItem, $saveItem, $saveAsItem, $browseItem))

# Chat Menu
$chatMenu = New-Object System.Windows.Forms.ToolStripMenuItem "Chat"
$menu.Items.Add($chatMenu) | Out-Null

$clearChatItem = New-Object System.Windows.Forms.ToolStripMenuItem "Clear Chat History"
$exportChatItem = New-Object System.Windows.Forms.ToolStripMenuItem "Export Chat History..."
$loadChatItem = New-Object System.Windows.Forms.ToolStripMenuItem "Load Chat History..."
$chatMenu.DropDownItems.AddRange(@($clearChatItem, $exportChatItem, $loadChatItem))

# Settings Menu
$settingsMenu = New-Object System.Windows.Forms.ToolStripMenuItem "Settings"
$menu.Items.Add($settingsMenu) | Out-Null

$modelSettingsItem = New-Object System.Windows.Forms.ToolStripMenuItem "AI Model & General..."
$editorSettingsItem = New-Object System.Windows.Forms.ToolStripMenuItem "Editor Settings..."
$chatSettingsItem = New-Object System.Windows.Forms.ToolStripMenuItem "Chat Settings..."
$themeSettingsItem = New-Object System.Windows.Forms.ToolStripMenuItem "Theme & Appearance..."
$settingsMenu.DropDownItems.AddRange(@($modelSettingsItem, $editorSettingsItem, $chatSettingsItem, $themeSettingsItem))

$exitItem = New-Object System.Windows.Forms.ToolStripMenuItem "Exit"
$fileMenu.DropDownItems.Add($exitItem)

# Command Palette (Ctrl+P or Ctrl+Shift+P)
$commandPalette = New-Object System.Windows.Forms.Form
$commandPalette.Text = "Command Palette"
$commandPalette.Size = New-Object System.Drawing.Size(600, 400)
$commandPalette.StartPosition = "CenterScreen"
$commandPalette.TopMost = $true
$commandPalette.FormBorderStyle = "None"
$commandPalette.BackColor = [System.Drawing.Color]::FromArgb(30, 30, 30)

# Command palette input
$paletteInput = New-Object System.Windows.Forms.TextBox
$paletteInput.Dock = [System.Windows.Forms.DockStyle]::Top
$paletteInput.Height = 40
$paletteInput.Font = New-Object System.Drawing.Font("Consolas", 12)
$paletteInput.BackColor = [System.Drawing.Color]::FromArgb(40, 40, 40)
$paletteInput.ForeColor = [System.Drawing.Color]::White
$commandPalette.Controls.Add($paletteInput) | Out-Null

# Command palette results
$paletteResults = New-Object System.Windows.Forms.ListBox
$paletteResults.Dock = [System.Windows.Forms.DockStyle]::Fill
$paletteResults.Font = New-Object System.Drawing.Font("Consolas", 10)
$paletteResults.BackColor = [System.Drawing.Color]::FromArgb(30, 30, 30)
$paletteResults.ForeColor = [System.Drawing.Color]::White
$commandPalette.Controls.Add($paletteResults) | Out-Null

# Command palette label
$paletteLabel = New-Object System.Windows.Forms.Label
$paletteLabel.Text = "Type a command or search extensions..."
$paletteLabel.Dock = [System.Windows.Forms.DockStyle]::Bottom
$paletteLabel.Height = 20
$paletteLabel.ForeColor = [System.Drawing.Color]::Gray
$paletteLabel.Font = New-Object System.Drawing.Font("Segoe UI", 8)
$commandPalette.Controls.Add($paletteLabel) | Out-Null

$commandPalette.Hide()

# Extensions Menu
$extensionsMenu = New-Object System.Windows.Forms.ToolStripMenuItem "Extensions"
$menu.Items.Add($extensionsMenu) | Out-Null

$marketplaceItem = New-Object System.Windows.Forms.ToolStripMenuItem "Marketplace..."
$installedItem = New-Object System.Windows.Forms.ToolStripMenuItem "Installed Extensions"
$extensionsMenu.DropDownItems.AddRange(@($marketplaceItem, $installedItem))

# Tools Menu
$toolsMenu = New-Object System.Windows.Forms.ToolStripMenuItem "Tools"
$menu.Items.Add($toolsMenu) | Out-Null

# Ollama Server submenu
$ollamaServerItem = New-Object System.Windows.Forms.ToolStripMenuItem "Ollama Server"
$ollamaStartItem = New-Object System.Windows.Forms.ToolStripMenuItem "Start Server"
$ollamaStopItem = New-Object System.Windows.Forms.ToolStripMenuItem "Stop Server"
$ollamaStatusItem = New-Object System.Windows.Forms.ToolStripMenuItem "Check Status"
$ollamaServerItem.DropDownItems.AddRange(@($ollamaStartItem, $ollamaStopItem, $ollamaStatusItem))
$toolsMenu.DropDownItems.Add($ollamaServerItem) | Out-Null

# Ollama menu event handlers
$ollamaStartItem.Add_Click({
        Write-DevConsole "Manual Ollama start requested..." "INFO"
        Start-OllamaServer
        Update-OllamaStatusDisplay
    })

$ollamaStopItem.Add_Click({
        Write-DevConsole "Manual Ollama stop requested..." "INFO"
        Stop-OllamaServer
        Update-OllamaStatusDisplay
    })

$ollamaStatusItem.Add_Click({
        $status = Get-OllamaStatus
        Write-DevConsole "Ollama Status Report:" "INFO"
        Write-DevConsole "  Status: $($status.Status)" "INFO"
        Write-DevConsole "  Process ID: $($status.ProcessId)" "INFO"
        Write-DevConsole "  Is Running: $($status.IsRunning)" "INFO"
        Write-DevConsole "  Connection Test: $($status.Connection)" "INFO"
        Update-OllamaStatusDisplay
    })

# Agent Mode Toggle - Start with Agent Mode ON for agentic editing
$global:AgentMode = $true
$toggle = New-Object System.Windows.Forms.ToolStripMenuItem
$toggle.Text = "Agent Mode: ON"
$toggle.ForeColor = 'Green'
$menu.Items.Add($toggle) | Out-Null

$toggle.Add_Click({
        $global:AgentMode = -not $global:AgentMode
        if ($global:AgentMode) {
            $toggle.Text = "Agent Mode: ON"
            $toggle.ForeColor = 'Green'
            $agentStatusLabel.Text = "Agent Status: Active - Agentic editing enabled"
            $agentStatusLabel.ForeColor = 'Green'
            $chatBox.AppendText("System > Agent Mode ENABLED - All agentic features active`r`n`r`n")
        }
        else {
            $toggle.Text = "Agent Mode: OFF"
            $toggle.ForeColor = 'Red'
            $agentStatusLabel.Text = "Agent Status: Inactive"
            $agentStatusLabel.ForeColor = 'Red'
            $chatBox.AppendText("System > Agent Mode DISABLED - Basic chat only`r`n`r`n")
        }
    })

# Chat History Functions
function Save-ChatHistory {
    try {
        $chatContent = $chatBox.Text
        if ($chatContent) {
            # Save current session to persistent file
            Set-Content -Path $script:chatHistoryPath -Value $chatContent -ErrorAction Stop
        }
    }
    catch {
        Write-Host "Error saving chat history: $_" -ForegroundColor Red
    }
}

function Get-ChatHistory {
    <#
    .SYNOPSIS
        Loads chat history from persistent storage
    .DESCRIPTION
        Retrieves and displays saved chat history from the application data directory
    #>
    [CmdletBinding()]
    param()
    
    try {
        if (Test-Path $script:chatHistoryPath) {
            $content = Get-Content -Path $script:chatHistoryPath -Raw -ErrorAction Stop
            if ($content) {
                $chatBox.Text = $content
                $chatBox.SelectionStart = $chatBox.TextLength
                $chatBox.ScrollToCaret()
            }
        }
    }
    catch {
        Write-Host "Error loading chat history: $_" -ForegroundColor Red
    }
}

function Clear-ChatHistory {
    $chatBox.Clear()
    Save-ChatHistory
}

function Export-ChatHistory {
    $dlg = New-Object System.Windows.Forms.SaveFileDialog
    $dlg.Filter = "Text Files (*.txt)|*.txt|All Files (*.*)|*.*"
    $dlg.FileName = "chat_history_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt"
    if ($dlg.ShowDialog() -eq "OK") {
        try {
            $chatBox.SaveFile($dlg.FileName, [System.Windows.Forms.RichTextBoxStreamType]::PlainText)
            Write-DevConsole "‚úÖ Chat history exported successfully to: $($dlg.FileName)" "SUCCESS"
        }
        catch {
            Write-DevConsole "‚ùå Error exporting chat: $_" "ERROR"
        }
    }
}

function Import-ChatHistory {
    $dlg = New-Object System.Windows.Forms.OpenFileDialog
    $dlg.Filter = "Text Files (*.txt)|*.txt|All Files (*.*)|*.*"
    if ($dlg.ShowDialog() -eq "OK") {
        try {
            $content = Get-Content -Path $dlg.FileName -Raw
            $chatBox.AppendText("`r`n`r`n=== Imported Chat History ===`r`n`r`n$content`r`n`r`n")
            $chatBox.SelectionStart = $chatBox.TextLength
            $chatBox.ScrollToCaret()
            Write-DevConsole "‚úÖ Chat history imported successfully from: $($dlg.FileName)" "SUCCESS"
        }
        catch {
            Write-DevConsole "‚ùå Error importing chat: $_" "ERROR"
        }
    }
}

# File Open
$openItem.Add_Click({
        $dlg = New-Object System.Windows.Forms.OpenFileDialog
        $dlg.Filter = "Text/Markdown (*.txt;*.md)|*.txt;*.md|All Files (*.*)|*.*"

        if ($dlg.ShowDialog() -eq "OK") {
            try {
                $editor.Text = [System.IO.File]::ReadAllText($dlg.FileName)
                $global:currentFile = $dlg.FileName
                $form.Text = "AI Text Editor - $($dlg.FileName)"
                Write-DevConsole "‚úÖ File opened successfully: $($dlg.FileName)" "SUCCESS"
            }
            catch {
                Write-DevConsole "‚ùå Error opening file: $_" "ERROR"
            }
        }
    })

# File Save
$saveItem.Add_Click({
        if ($global:currentFile) {
            try {
                [System.IO.File]::WriteAllText($global:currentFile, $editor.Text)
                $form.Text = "AI Text Editor - 3 Pane - Saved"
                Write-DevConsole "‚úÖ File saved successfully: $global:currentFile" "SUCCESS"
            }
            catch {
                Write-DevConsole "‚ùå Error saving file: $_" "ERROR"
            }
        }
        else {
            # If no file, use Save As dialog
            $dlg = New-Object System.Windows.Forms.SaveFileDialog
            $dlg.Filter = "Text Files (*.txt)|*.txt|Markdown (*.md)|*.md|All Files (*.*)|*.*"
            if ($dlg.ShowDialog() -eq "OK") {
                try {
                    [System.IO.File]::WriteAllText($dlg.FileName, $editor.Text)
                    $global:currentFile = $dlg.FileName
                    $form.Text = "AI Text Editor - $($dlg.FileName)"
                    Write-DevConsole "‚úÖ File saved as: $($dlg.FileName)" "SUCCESS"
                }
                catch {
                    Write-DevConsole "‚ùå Error saving file: $_" "ERROR"
                }
            }
        }
    })

# File Save As
$saveAsItem.Add_Click({
        $dlg = New-Object System.Windows.Forms.SaveFileDialog
        $dlg.Filter = "Text Files (*.txt)|*.txt|Markdown (*.md)|*.md|All Files (*.*)|*.*"
        if ($global:currentFile) {
            $dlg.FileName = $global:currentFile
        }
        if ($dlg.ShowDialog() -eq "OK") {
            try {
                [System.IO.File]::WriteAllText($dlg.FileName, $editor.Text)
                $global:currentFile = $dlg.FileName
                $form.Text = "AI Text Editor - $($dlg.FileName)"
                Write-DevConsole "‚úÖ File saved as: $($dlg.FileName)" "SUCCESS"
            }
            catch {
                Write-DevConsole "‚ùå Error saving file as: $_" "ERROR"
            }
        }
    })

# Folder Browser
$browseItem.Add_Click({
        $folder = New-Object System.Windows.Forms.FolderBrowserDialog
        if ($folder.ShowDialog() -eq "OK") {
            Write-DevConsole "Folder selected: $($folder.SelectedPath)" "INFO"
            # Update working directory to selected folder
            $global:currentWorkingDir = $folder.SelectedPath
            Update-Explorer
        }
    })

# Chat Menu Event Handlers
$clearChatItem.Add_Click({
        # Confirm clear chat operation through console
        Write-DevConsole "üóëÔ∏è Clearing chat history..." "INFO"
        Clear-ChatHistory
        Write-DevConsole "‚úÖ Chat history cleared successfully" "SUCCESS"
    })

$exportChatItem.Add_Click({
        Export-ChatHistory
    })

$loadChatItem.Add_Click({
        Import-ChatHistory
    })

# Extensions Menu Event Handlers
$marketplaceItem.Add_Click({
        Show-Marketplace
    })

$installedItem.Add_Click({
        Show-InstalledExtensions
    })

# Command Palette Event Handlers
$paletteInput.Add_TextChanged({
        Update-CommandPalette
    })

$paletteInput.Add_KeyDown({
        if ($_.KeyCode -eq "Enter") {
            Invoke-CommandPaletteSelection
            $_.Handled = $true
        }
        elseif ($_.KeyCode -eq "Escape") {
            Hide-CommandPalette
            $_.Handled = $true
        }
        elseif ($_.KeyCode -eq "Up") {
            if ($paletteResults.SelectedIndex -gt 0) {
                $paletteResults.SelectedIndex--
            }
            $_.Handled = $true
        }
        elseif ($_.KeyCode -eq "Down") {
            if ($paletteResults.SelectedIndex -lt ($paletteResults.Items.Count - 1)) {
                $paletteResults.SelectedIndex++
            }
            $_.Handled = $true
        }
    })

$paletteResults.Add_DoubleClick({
        Invoke-CommandPaletteSelection
    })

# Global keyboard hook for Ctrl+P
$form.KeyPreview = $true
$form.Add_KeyDown({
        if ($_.Control -and $_.KeyCode -eq "P") {
            Show-CommandPalette
            $_.Handled = $true
        }
    })

# Settings menu event handlers
$modelSettingsItem.Add_Click({
        Show-ModelSettings
    })

$editorSettingsItem.Add_Click({
        Show-EditorSettings
    })

$themeSettingsItem.Add_Click({
        Write-DevConsole "‚ÑπÔ∏è Theme settings feature coming soon!" "INFO"
    })

# Exit - Save chat before closing
$exitItem.Add_Click({
        Save-ChatHistory
        $form.Close()
    })

# Function to send HTTP request to Ollama API
function Send-OllamaRequest {
    param(
        [string]$Prompt,
        [string]$Model = $OllamaModel #Use default model if no specific model is provided
    )

    Write-DevConsole "Sending request to Ollama API (Model: $Model)" "DEBUG"
    
    # Validate model exists first
    try {
        Write-DevConsole "Validating model availability..." "DEBUG"
        $modelsResponse = Invoke-RestMethod -Uri "http://localhost:11434/api/tags" -Method GET -TimeoutSec 10
        $availableModels = $modelsResponse.models | ForEach-Object { $_.name }
        
        if ($Model -notin $availableModels) {
            Write-DevConsole "Model '$Model' not found. Available models: $($availableModels -join ', ')" "ERROR"
            if ($availableModels.Count -gt 0) {
                $fallbackModel = $availableModels[0]
                Write-DevConsole "Using fallback model: $fallbackModel" "WARNING"
                $Model = $fallbackModel
            }
            else {
                return "Error: No models available. Please install a model using 'ollama pull <model>'"
            }
        }
    }
    catch {
        Write-DevConsole "Could not validate models (server may be down): $_" "WARNING"
        # Continue with original model - might work if server is just slow
    }
    
    $body = @{
        model  = $Model
        prompt = $Prompt
        stream = $false
    }
    
    # Retry logic with exponential backoff
    $maxRetries = 3
    $retryCount = 0
    
    while ($retryCount -lt $maxRetries) {
        try {
            $jsonBody = $body | ConvertTo-Json -Depth 10
            
            Write-DevConsole "Attempt $($retryCount + 1)/$maxRetries - POST $OllamaAPIEndpoint" "DEBUG"
            
            $response = Invoke-RestMethod -Uri $OllamaAPIEndpoint -Method POST -Body $jsonBody -ContentType "application/json" -TimeoutSec 30
            
            # Parse response
            if ($response.response) {
                Write-DevConsole "Ollama response received ($($response.response.Length) chars)" "SUCCESS"
                return $response.response
            }
            elseif ($response.error) {
                Write-DevConsole "Ollama API returned error: $($response.error)" "ERROR"
                return "Ollama Error: $($response.error)"
            }
            else {
                Write-DevConsole "Ollama response received (raw)" "SUCCESS" 
                return $response.ToString()
            }
        }
        catch {
            $retryCount++
            $errorMsg = $_.Exception.Message
            
            if ($errorMsg -match "Unable to connect|refused|timeout|not found") {
                Write-DevConsole "Network error (attempt $retryCount): $errorMsg" "ERROR"
                
                if ($retryCount -lt $maxRetries) {
                    $backoffMs = [math]::Pow(2, $retryCount) * 500  # 500ms, 1s, 2s
                    Write-DevConsole "Retrying in $($backoffMs)ms..." "INFO"
                    Start-Sleep -Milliseconds $backoffMs
                    continue
                }
            }
            
            Write-DevConsole "Ollama API Error (final): $errorMsg" "ERROR"
            
            # Provide helpful diagnostic info
            $diagnosticMsg = @"
Connection failed to Ollama API at $OllamaAPIEndpoint

Troubleshooting steps:
1. Check if Ollama is running: Test-NetConnection -ComputerName localhost -Port 11434
2. Start Ollama service if needed: ollama serve
3. Verify models are installed: ollama list
4. Test endpoint manually: Invoke-RestMethod -Uri http://localhost:11434/api/tags

Error details: $errorMsg
"@
            
            return $diagnosticMsg
        }
    }
    
    return "Error: Failed to connect to Ollama after $maxRetries attempts"
}


# Chat Function
function Send-Chat {
    param($msg)

    if (-not $msg.Trim()) { return }

    Write-DevConsole "User message: $msg" "INFO"
    
    # Append user message to chat
    $chatBox.AppendText("You > $msg`r`n")
    
    # Auto-save chat history after each message
    Save-ChatHistory

    # Handle Agent Mode
    if ($global:AgentMode) {
        # System command execution
        if ($msg -match "^/sys\s+(.+)$") {
            $cmd = $Matches[1]
            try {
                $out = powershell -command "$cmd"
                $chatBox.AppendText("SYS > $out`r`n`r`n")
            }
            catch {
                $chatBox.AppendText("SYS-ERR > $_`r`n`r`n")
            }
            return
        }

        # Browser navigation commands
        if ($msg -match "^/browse\s+(.+)$" -or $msg -match "^/nav\s+(.+)$" -or $msg -match "^/go\s+(.+)$") {
            $url = $Matches[1]
            Open-Browser $url
            $chatBox.AppendText("Agent > Navigating to: $url`r`n")
            # Switch to browser tab
            $rightTabControl.SelectedTab = $browserTab
            return
        }

        # Get current page info
        if ($msg -match "^/pageinfo$" -or $msg -match "^/browserinfo$") {
            try {
                if ($script:browserType -eq "WebView2" -and $webBrowser.CoreWebView2) {
                    $title = $webBrowser.CoreWebView2.DocumentTitle
                    $url = $webBrowser.CoreWebView2.Source.ToString()
                    $chatBox.AppendText("Agent > Current Page:`r`nTitle: $title`r`nURL: $url`r`n`r`n")
                }
                else {
                    $title = $webBrowser.DocumentTitle
                    $url = $webBrowser.Url.ToString()
                    $chatBox.AppendText("Agent > Current Page:`r`nTitle: $title`r`nURL: $url`r`n`r`n")
                }
            }
            catch {
                $chatBox.AppendText("Agent > Error getting page info: $_`r`n`r`n")
            }
            return
        }

        # Browser back/forward
        if ($msg -eq "/back" -or $msg -eq "/browserback") {
            $browserBackBtn.PerformClick()
            $chatBox.AppendText("Agent > Navigated back`r`n")
            return
        }

        if ($msg -eq "/forward" -or $msg -eq "/browserforward") {
            $browserForwardBtn.PerformClick()
            $chatBox.AppendText("Agent > Navigated forward`r`n")
            return
        }

        # Browser refresh
        if ($msg -eq "/refresh" -or $msg -eq "/reload") {
            $browserRefreshBtn.PerformClick()
            $chatBox.AppendText("Agent > Refreshed page`r`n")
            return
        }

        # Extract page content
        if ($msg -match "^/extract$" -or $msg -match "^/getcontent$") {
            try {
                if ($script:browserType -eq "WebView2" -and $webBrowser.CoreWebView2) {
                    $script = "document.body.innerText"
                    $content = $webBrowser.CoreWebView2.ExecuteScriptAsync($script).Result
                    $content = $content -replace '"', '' -replace '\\n', "`r`n"
                    $chatBox.AppendText("Agent > Page Content:`r`n$content`r`n`r`n")
                }
                else {
                    $content = $webBrowser.Document.Body.InnerText
                    $chatBox.AppendText("Agent > Page Content:`r`n$content`r`n`r`n")
                }
            }
            catch {
                $chatBox.AppendText("Agent > Error extracting content: $_`r`n`r`n")
            }
            return
        }

        # Search YouTube
        if ($msg -match "^/youtube\s+(.+)$" -or $msg -match "^/yt\s+(.+)$") {
            $query = $Matches[1]
            $encodedQuery = [System.Uri]::EscapeDataString($query)
            $searchUrl = "https://www.youtube.com/results?search_query=$encodedQuery"
            Open-Browser $searchUrl
            $chatBox.AppendText("Agent > Searching YouTube for: $query`r`n")
            $rightTabControl.SelectedTab = $browserTab
            return
        }

        # Natural language browser commands
        if ($msg -match "open\s+(https?://[^\s]+|www\.[^\s]+|[^\s]+\.(com|org|net|io|edu|gov))" -or 
            $msg -match "navigate\s+to\s+(https?://[^\s]+|www\.[^\s]+|[^\s]+\.(com|org|net|io|edu|gov))" -or
            $msg -match "go\s+to\s+(https?://[^\s]+|www\.[^\s]+|[^\s]+\.(com|org|net|io|edu|gov))") {
            $url = $Matches[1]
            Open-Browser $url
            $chatBox.AppendText("Agent > Opening: $url`r`n")
            $rightTabControl.SelectedTab = $browserTab
            return
        }

        if ($msg -match "search\s+youtube\s+for\s+(.+)$" -or $msg -match "youtube\s+search\s+(.+)$") {
            $query = $Matches[1]
            $encodedQuery = [System.Uri]::EscapeDataString($query)
            $searchUrl = "https://www.youtube.com/results?search_query=$encodedQuery"
            Open-Browser $searchUrl
            $chatBox.AppendText("Agent > Searching YouTube for: $query`r`n")
            $rightTabControl.SelectedTab = $browserTab
            return
        }

        # Enhanced natural language browser commands
        if ($msg -match "(?:search|google|find)\s+(?:for\s+)?(.+)" -and $msg -notmatch "youtube") {
            $query = $Matches[1]
            $encodedQuery = [System.Uri]::EscapeDataString($query)
            $searchUrl = "https://www.google.com/search?q=$encodedQuery"
            Open-Browser $searchUrl
            $chatBox.AppendText("Agent > Searching Google for: $query`r`n")
            $rightTabControl.SelectedTab = $browserTab
            return
        }

        if ($msg -match "(?:show|display|view)\s+(?:the\s+)?(?:web\s+)?browser") {
            $rightTabControl.SelectedTab = $browserTab
            $chatBox.AppendText("Agent > Switched to browser`r`n`r`n")
            return
        }

        if ($msg -match "extract\s+(?:page\s+)?(?:content|text)|get\s+(?:page\s+)?(?:content|text)|read\s+(?:the\s+)?page") {
            try {
                if ($script:browserType -eq "WebView2" -and $webBrowser.CoreWebView2) {
                    $script = "document.body.innerText"
                    $content = $webBrowser.CoreWebView2.ExecuteScriptAsync($script).Result
                    $content = $content -replace '"', '' -replace '\\n', "`r`n"
                    $chatBox.AppendText("Agent > Page Content:`r`n$content`r`n`r`n")
                }
                else {
                    $content = $webBrowser.Document.Body.InnerText
                    $chatBox.AppendText("Agent > Page Content:`r`n$content`r`n`r`n")
                }
            }
            catch {
                $chatBox.AppendText("Agent > Error extracting content: $_`r`n`r`n")
            }
            return
        }

        # Apply editor content
        if ($msg -eq "/apply") {
            $lines = $chatBox.Lines
            if ($lines.Count -ge 1) {
                $lastAI = $lines[-1]
                $editor.Text = $lastAI
                $chatBox.AppendText("Agent > Applied AI output to editor.`r`n`r`n")
            }
            return
        }

        # ============================================
        # Git Agentic Commands
        # ============================================
        if ($msg -match "^/git\s+status$" -or $msg -eq "/gitstatus") {
            $status = Get-GitStatus
            $chatBox.AppendText("Agent > Git Status:`r`n$status`r`n`r`n")
            Update-GitStatus
            $rightTabControl.SelectedTab = $gitTab
            return
        }

        if ($msg -match "^/git\s+add\s+(.+)$") {
            $files = $Matches[1]
            $result = Invoke-GitCommand "add" @($files)
            $chatBox.AppendText("Agent > Git add: $result`r`n`r`n")
            Update-GitStatus
            return
        }

        if ($msg -match "^/git\s+commit\s+-m\s+['""](.+)['""]$" -or $msg -match "^/git\s+commit\s+-m\s+(.+)$") {
            $message = $Matches[1]
            $result = Invoke-GitCommand "commit" @("-m", $message)
            $chatBox.AppendText("Agent > Git commit: $result`r`n`r`n")
            Update-GitStatus
            return
        }

        if ($msg -match "^/git\s+push$" -or $msg -eq "/gitpush") {
            $result = Invoke-GitCommand "push" @()
            $chatBox.AppendText("Agent > Git push: $result`r`n`r`n")
            Update-GitStatus
            return
        }

        if ($msg -match "^/git\s+pull$" -or $msg -eq "/gitpull") {
            $result = Invoke-GitCommand "pull" @()
            $chatBox.AppendText("Agent > Git pull: $result`r`n`r`n")
            Update-GitStatus
            return
        }

        if ($msg -match "^/git\s+branch\s+(.+)$") {
            $branch = $Matches[1]
            $result = Invoke-GitCommand "checkout" @("-b", $branch)
            $chatBox.AppendText("Agent > Git branch: $result`r`n`r`n")
            Update-GitStatus
            return
        }

        if ($msg -match "^/git\s+(.+)$") {
            $gitCmd = $Matches[1]
            $result = Invoke-GitCommand $gitCmd @()
            $chatBox.AppendText("Agent > Git $gitCmd : $result`r`n`r`n")
            Update-GitStatus
            return
        }

        # Natural language Git commands
        if ($msg -match "commit\s+(?:changes|code|files)" -or $msg -match "git\s+commit") {
            $result = Invoke-GitCommand "status" @()
            if ($result -match "Changes to be committed" -or $result -match "modified:") {
                $commitMsg = "Auto-commit by agent"
                $result = Invoke-GitCommand "commit" @("-m", $commitMsg)
                $chatBox.AppendText("Agent > Committed changes: $result`r`n`r`n")
            }
            else {
                $chatBox.AppendText("Agent > No changes to commit`r`n`r`n")
            }
            Update-GitStatus
            return
        }

        # ============================================
        # Terminal Agentic Commands
        # ============================================
        if ($msg -match "^/term\s+(.+)$" -or $msg -match "^/terminal\s+(.+)$" -or $msg -match "^/exec\s+(.+)$") {
            $command = $Matches[1]
            Invoke-TerminalCommand $command
            $chatBox.AppendText("Agent > Executed: $command`r`n")
            $rightTabControl.SelectedTab = $terminalTab
            return
        }

        if ($msg -eq "/terminal" -or $msg -eq "/term") {
            $rightTabControl.SelectedTab = $terminalTab
            $chatBox.AppendText("Agent > Switched to terminal`r`n`r`n")
            return
        }

        # Enhanced natural language terminal commands
        if ($msg -match "(?:run|execute)\s+(?:command\s+)?(.+)" -or
            $msg -match "(?:in|use)\s+(?:the\s+)?terminal\s+(?:run\s+)?(.+)") {
            $command = $Matches[1].Trim()
            Invoke-TerminalCommand $command
            $chatBox.AppendText("Agent > Executed in terminal: $command`r`n")
            $rightTabControl.SelectedTab = $terminalTab
            return
        }

        if ($msg -match "(?:show|open|display)\s+(?:the\s+)?terminal") {
            $rightTabControl.SelectedTab = $terminalTab
            $chatBox.AppendText("Agent > Switched to terminal`r`n`r`n")
            return
        }

        # ============================================
        # File Browser Agentic Commands
        # ============================================
        if ($msg -match "^/cd\s+(.+)$" -or $msg -match "^/navigate\s+(.+)$") {
            $path = $Matches[1]
            if (Test-Path $path) {
                $global:currentWorkingDir = Resolve-Path $path
                Set-Location $global:currentWorkingDir
                Update-Explorer
                $chatBox.AppendText("Agent > Changed directory to: $global:currentWorkingDir`r`n`r`n")
            }
            else {
                $chatBox.AppendText("Agent > Path not found: $path`r`n`r`n")
            }
            return
        }

        if ($msg -match "^/ls\s*(.*)$" -or $msg -match "^/list\s*(.*)$" -or $msg -match "^/dir\s*(.*)$") {
            $path = if ($Matches[1]) { $Matches[1] } else { $global:currentWorkingDir }
            try {
                $items = Get-ChildItem -Path $path -ErrorAction Stop
                $output = "Contents of $path :`r`n"
                foreach ($item in $items) {
                    $type = if ($item.PSIsContainer) { "[DIR]" } else { "[FILE]" }
                    $output += "$type $($item.Name)`r`n"
                }
                $chatBox.AppendText("Agent > $output`r`n")
            }
            catch {
                $chatBox.AppendText("Agent > Error: $_`r`n`r`n")
            }
            return
        }

        if ($msg -match "^/read\s+(.+)$" -or $msg -match "^/open\s+(.+)$") {
            $filePath = $Matches[1]
            if (Test-Path $filePath) {
                try {
                    $content = [System.IO.File]::ReadAllText($filePath)
                    $editor.Text = $content
                    $global:currentFile = $filePath
                    $form.Text = "AI Text Editor - $filePath"
                    $chatBox.AppendText("Agent > Opened file: $filePath`r`n`r`n")
                }
                catch {
                    $chatBox.AppendText("Agent > Error reading file: $_`r`n`r`n")
                }
            }
            else {
                $chatBox.AppendText("Agent > File not found: $filePath`r`n`r`n")
            }
            return
        }

        if ($msg -match "^/write\s+(.+?)\s+(.+)$" -or $msg -match "^/save\s+(.+?)\s+(.+)$") {
            $filePath = $Matches[1]
            $content = $Matches[2]
            try {
                [System.IO.File]::WriteAllText($filePath, $content)
                $chatBox.AppendText("Agent > Wrote to file: $filePath`r`n`r`n")
            }
            catch {
                $chatBox.AppendText("Agent > Error writing file: $_`r`n`r`n")
            }
            return
        }

        if ($msg -eq "/browse" -or $msg -eq "/explorer") {
            $folder = New-Object System.Windows.Forms.FolderBrowserDialog
            if ($folder.ShowDialog() -eq "OK") {
                $global:currentWorkingDir = $folder.SelectedPath
                Update-Explorer
                $chatBox.AppendText("Agent > Browsed: $($folder.SelectedPath)`r`n`r`n")
            }
            return
        }

        # Enhanced natural language file/directory commands
        if ($msg -match "(?:show|list|display)\s+(?:me\s+)?(?:the\s+)?files?\s+(?:in\s+)?(.+)" -or 
            $msg -match "(?:what's|whats)\s+in\s+(?:the\s+)?(?:folder|directory)\s+(.+)") {
            $path = $Matches[1].Trim()
            if (-not $path -or $path -eq "here" -or $path -eq "current") {
                $path = $global:currentWorkingDir
            }
            try {
                $items = Get-ChildItem -Path $path -ErrorAction Stop
                $output = "Contents of $path :`r`n"
                foreach ($item in $items) {
                    $type = if ($item.PSIsContainer) { "[DIR]" } else { "[FILE]" }
                    $size = if (-not $item.PSIsContainer) { " ($([math]::Round($item.Length/1KB, 2)) KB)" } else { "" }
                    $output += "$type $($item.Name)$size`r`n"
                }
                $chatBox.AppendText("Agent > $output`r`n")
            }
            catch {
                $chatBox.AppendText("Agent > Error: $_`r`n`r`n")
            }
            return
        }

        if ($msg -match "(?:change|go|navigate)\s+(?:to\s+)?(?:directory|folder|path)\s+(.+)" -or
            $msg -match "(?:move|switch)\s+to\s+(.+)" -or
            $msg -match "(?:goto|cd)\s+(.+)") {
            $path = $Matches[1].Trim() -replace '["'']', ''
            
            # If it's a relative path, try to resolve it from current directory first
            if (-not [System.IO.Path]::IsPathRooted($path)) {
                $possiblePath = Join-Path $global:currentWorkingDir $path
                if (Test-Path $possiblePath) {
                    $path = $possiblePath
                }
            }
            
            if (Test-Path $path) {
                $global:currentWorkingDir = Resolve-Path $path
                Set-Location $global:currentWorkingDir
                Update-Explorer
                $explorerPathLabel.Text = "Path: $global:currentWorkingDir"
                $chatBox.AppendText("Agent > ‚úì Changed directory to: $global:currentWorkingDir`r`n`r`n")
            }
            else {
                $chatBox.AppendText("Agent > ‚úó Path not found: $path`r`n")
                $chatBox.AppendText("        Current directory: $global:currentWorkingDir`r`n")
                $chatBox.AppendText("        Tip: Use full path like 'C:\Users\...' or relative like 'Powershield'`r`n`r`n")
            }
            return
        }

        if ($msg -match "(?:open|load|read)\s+(?:the\s+)?(?:file|project)\s+(.+)" -or
            $msg -match "(?:show|display)\s+(?:me\s+)?(?:the\s+)?(?:file|code)\s+(.+)") {
            $filePath = $Matches[1].Trim() -replace '["'']', ''
            
            # Try relative path first, then absolute
            if (-not (Test-Path $filePath)) {
                $fullPath = Join-Path $global:currentWorkingDir $filePath
                if (Test-Path $fullPath) {
                    $filePath = $fullPath
                }
            }
            
            if (Test-Path $filePath) {
                try {
                    $fileInfo = Get-Item $filePath
                    if ($fileInfo.PSIsContainer) {
                        # It's a directory/project
                        $global:currentWorkingDir = $filePath
                        Set-Location $global:currentWorkingDir
                        Update-Explorer
                        $explorerPathLabel.Text = "Path: $global:currentWorkingDir"
                        $chatBox.AppendText("Agent > Opened project folder: $filePath`r`n`r`n")
                    }
                    else {
                        # It's a file
                        $content = [System.IO.File]::ReadAllText($filePath)
                        $editor.Text = $content
                        $global:currentFile = $filePath
                        $form.Text = "AI Text Editor - $filePath"
                        $chatBox.AppendText("Agent > Opened file: $filePath ($($fileInfo.Length) bytes)`r`n`r`n")
                    }
                }
                catch {
                    $chatBox.AppendText("Agent > Error opening: $_`r`n`r`n")
                }
            }
            else {
                $chatBox.AppendText("Agent > File not found: $filePath`r`n`r`n")
            }
            return
        }

        if ($msg -match "(?:show|open|display)\s+(?:the\s+)?(?:file\s+)?(?:explorer|browser|tree)") {
            Update-Explorer
            $chatBox.AppendText("Agent > File explorer refreshed. Current path: $global:currentWorkingDir`r`n`r`n")
            return
        }

        if ($msg -match "(?:save|write)\s+(?:this|the|current)\s+(?:file|code|content)(?:\s+as\s+(.+))?") {
            $fileName = if ($Matches[1]) { $Matches[1].Trim() -replace '["'']', '' } else { $global:currentFile }
            
            if (-not $fileName) {
                $chatBox.AppendText("Agent > Please specify a filename`r`n`r`n")
                return
            }
            
            try {
                [System.IO.File]::WriteAllText($fileName, $editor.Text)
                $global:currentFile = $fileName
                $form.Text = "AI Text Editor - $fileName"
                $chatBox.AppendText("Agent > Saved file: $fileName ($($editor.Text.Length) bytes)`r`n`r`n")
            }
            catch {
                $chatBox.AppendText("Agent > Error saving file: $_`r`n`r`n")
            }
            return
        }

        if ($msg -match "(?:create|make)\s+(?:a\s+)?(?:new\s+)?(?:file|project)\s+(?:called\s+|named\s+)?(.+)") {
            $fileName = $Matches[1].Trim() -replace '["'']', ''
            try {
                $fullPath = Join-Path $global:currentWorkingDir $fileName
                [System.IO.File]::WriteAllText($fullPath, "")
                $editor.Text = ""
                $global:currentFile = $fullPath
                $form.Text = "AI Text Editor - $fullPath"
                Update-Explorer
                $chatBox.AppendText("Agent > Created new file: $fullPath`r`n`r`n")
            }
            catch {
                $chatBox.AppendText("Agent > Error creating file: $_`r`n`r`n")
            }
            return
        }

        # ============================================
        # Agentic Workflow Commands
        # ============================================
        if ($msg -match "^/workflow\s+(.+)$" -or $msg -match "^/task\s+(.+)$" -or $msg -match "^/agent\s+(.+)$") {
            $goal = $Matches[1]
            $context = if ($editor.Text) { "Current file: $($editor.Text.Substring(0, [Math]::Min(500, $editor.Text.Length)))" } else { "" }
            $task = Invoke-AgenticWorkflow -Goal $goal -Context $context
            $chatBox.AppendText("Agent > Started workflow: $goal`r`nTask ID: $($task.Id)`r`n`r`n")
            $rightTabControl.SelectedTab = $agentTasksTab
            return
        }

        if ($msg -match "^/tools$" -or $msg -eq "/listtools") {
            $tools = Get-AgentToolsSchema
            $chatBox.AppendText("Agent > Available Tools:`r`n")
            foreach ($tool in $tools) {
                $chatBox.AppendText("  - $($tool.name): $($tool.description)`r`n")
            }
            $chatBox.AppendText("`r`n")
            return
        }

        if ($msg -match "^/env$" -or $msg -eq "/environment") {
            $env = Get-EnvironmentInfo
            $chatBox.AppendText("Agent > Environment Info:`r`n")
            foreach ($key in $env.Keys) {
                $chatBox.AppendText("  $key : $($env[$key])`r`n")
            }
            $chatBox.AppendText("`r`n")
            return
        }

        if ($msg -match "^/deps\s*(.*)$") {
            $path = if ($Matches[1]) { $Matches[1] } else { $global:currentWorkingDir }
            $deps = Get-ProjectDependencies -Path $path
            $chatBox.AppendText("Agent > Dependencies for $path :`r`n")
            $chatBox.AppendText("  Type: $($deps.Type)`r`n")
            $chatBox.AppendText("  Build System: $($deps.BuildSystem)`r`n")
            $chatBox.AppendText("  Dependencies: $($deps.Dependencies -join ', ')`r`n`r`n")
            return
        }

        # ============================================
        # Coding/Copilot Commands
        # ============================================
        if ($msg -match "^/code\s+(.+)$" -or $msg -match "^/generate\s+(.+)$") {
            $prompt = $Matches[1]
            $context = if ($editor.Text) { "Current editor content: $($editor.Text)" } else { "" }
            try {
                $code = Invoke-CodeGeneration $prompt $context
                
                # Add code to editor
                $editor.Text = $code
                
                # Display formatted code block in chat
                $codeLines = $code -split "`n"
                $chatBox.AppendText("Agent > Generated code ($($codeLines.Count) lines):`r`n")
                $chatBox.AppendText("‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ`r`n")
                
                # Show first few lines as preview
                $previewLines = $codeLines | Select-Object -First 10
                foreach ($line in $previewLines) {
                    $chatBox.AppendText("‚îÇ $line`r`n")
                }
                
                if ($codeLines.Count -gt 10) {
                    $chatBox.AppendText("‚îÇ ... ($($codeLines.Count - 10) more lines)`r`n")
                }
                
                $chatBox.AppendText("‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ`r`n")
                $chatBox.AppendText("üí° Full code has been placed in the editor.`r`n`r`n")
                
                # Switch focus to editor
                $leftSplitter.Panel2.Focus()
                Write-DevConsole "Generated $($codeLines.Count) lines of code" "SUCCESS"
            }
            catch {
                $chatBox.AppendText("Agent > Error generating code: $_`r`n`r`n")
                Write-DevConsole "Code generation error: $_" "ERROR"
            }
            return
        }

        if ($msg -eq "/review" -or $msg -match "^/review\s+(.+)$") {
            $code = if ($msg -match "^/review\s+(.+)$") { $Matches[1] } else { $editor.Text }
            
            if ($code -and $code.Trim()) {
                $codeLength = $code.Length
                $lineCount = ($code -split "`n").Count
                
                $chatBox.AppendText("Agent > Reviewing code ($codeLength characters, $lineCount lines)...`r`n`r`n")
                
                try {
                    $review = Invoke-CodeReview $code
                    $chatBox.AppendText("Agent > Code Review:`r`n")
                    $chatBox.AppendText("$review`r`n`r`n")
                }
                catch {
                    $chatBox.AppendText("Agent > Error reviewing code: $_`r`n`r`n")
                    Write-DevConsole "Code review error: $_" "ERROR"
                }
            }
            else {
                $currentFile = if ($global:currentFile) { Split-Path -Leaf $global:currentFile } else { "none" }
                $chatBox.AppendText("Agent > No code to review in editor.`r`n")
                $chatBox.AppendText("Current file: $currentFile`r`n")
                $chatBox.AppendText("Editor content length: $($editor.Text.Length) characters`r`n")
                $chatBox.AppendText("Tip: Open a file or paste code into the editor first.`r`n`r`n")
            }
            return
        }

        # /tools - List all available agent tools
        if ($msg -eq "/tools" -or $msg -match "^/tools\s*(.*)$") {
            $filter = if ($msg -match "^/tools\s+(.+)$") { $Matches[1] } else { "" }
            
            $chatBox.AppendText("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó`r`n")
            $chatBox.AppendText("‚ïë         üîß REGISTERED AGENT TOOLS                  ‚ïë`r`n")
            $chatBox.AppendText("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`r`n`r`n")
            
            $categories = Get-AgentToolsList
            $toolCount = 0
            
            foreach ($category in ($categories.Keys | Sort-Object)) {
                if ($filter -and $category -notmatch $filter) { continue }
                
                $chatBox.AppendText("üìÅ $category`r`n")
                $chatBox.AppendText(("‚îÄ" * 50) + "`r`n")
                
                foreach ($tool in $categories[$category]) {
                    $toolCount++
                    $chatBox.AppendText("  ‚Ä¢ $($tool.name) (v$($tool.version))`r`n")
                    $chatBox.AppendText("    $($tool.description)`r`n")
                    if ($tool.parameters) {
                        $chatBox.AppendText("    Parameters: $($tool.parameters)`r`n")
                    }
                    $chatBox.AppendText("`r`n")
                }
            }
            
            $chatBox.AppendText("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`r`n")
            $chatBox.AppendText("Total: $toolCount tools registered across $($categories.Count) categories`r`n")
            $chatBox.AppendText("`r`nUsage: Type commands naturally or use /execute_tool <name> <params>`r`n`r`n")
            return
        }

        # /execute_tool - Execute a specific tool
        if ($msg -match "^/execute[_\-]?tool\s+(\w+)(?:\s+(.+))?$") {
            $toolName = $Matches[1]
            $paramsJson = if ($Matches[2]) { $Matches[2] } else { "{}" }
            
            try {
                $params = ConvertFrom-Json $paramsJson -AsHashtable
                $result = Invoke-AgentTool -ToolName $toolName -Parameters $params
                
                $chatBox.AppendText("üîß Tool: $toolName`r`n")
                $chatBox.AppendText("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`r`n")
                
                if ($result.success) {
                    $chatBox.AppendText("‚úì Success`r`n`r`n")
                    $resultJson = ($result | ConvertTo-Json -Depth 5)
                    $chatBox.AppendText($resultJson + "`r`n`r`n")
                }
                else {
                    $chatBox.AppendText("‚úó Error: $($result.error)`r`n`r`n")
                }
            }
            catch {
                $chatBox.AppendText("Agent > Error executing tool: $_`r`n`r`n")
            }
            return
        }

        if ($msg -match "^/refactor\s+(.+)$") {
            $instructions = $Matches[1]
            $code = $editor.Text
            if ($code) {
                try {
                    $refactored = Invoke-CodeRefactor $code $instructions
                    $chatBox.AppendText("Agent > Refactored code:`r`n$refactored`r`n`r`n")
                    $editor.Text = $refactored
                }
                catch {
                    $chatBox.AppendText("Agent > Error refactoring code: $_`r`n`r`n")
                }
            }
            else {
                $chatBox.AppendText("Agent > No code to refactor`r`n`r`n")
            }
            return
        }

        if ($msg -match "summarize|rewrite|cleaner|improve|refactor") {
            $content = $editor.Text

            if (-not $content.Trim()) {
                $chatBox.AppendText("Agent > Left editor is empty.`r`n`r`n")
                return
            }

            $prompt = @"
Here is the full text editor content. Summarize or rewrite it cleaner.

TEXT START:
$content
TEXT END:
"@

            try {
                $response = Send-OllamaRequest $prompt
                $chatBox.AppendText("AI > $response`r`n`r`n")
                Save-ChatHistory
            }
            catch {
                $chatBox.AppendText("AI-ERR > $_`r`n`r`n")
                Save-ChatHistory
            }
            return
        }
    }

    # Normal Chat Mode
    if ($msg -match "^/chat\s+(.+?)\s+(.+)$") {
        $model = $Matches[1]
        $prompt = $Matches[2]
    }
    else {
        $model = $OllamaModel
        $prompt = $msg
    }

    try {
        $response = Send-OllamaRequest $prompt $model
        $chatBox.AppendText("AI > $response`r`n`r`n")
        # Save chat history after AI response
        Save-ChatHistory
    }
    catch {
        $chatBox.AppendText("Error: $_`r`n`r`n")
        Save-ChatHistory
    }
}

# Browser Navigation Function
function Open-Browser {
    <#
    .SYNOPSIS
        Opens a URL in the embedded browser
    .PARAMETER Url
        The URL to navigate to
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$url
    )
    if ($url) {
        if (-not $url.StartsWith("http://") -and -not $url.StartsWith("https://")) {
            $url = "https://" + $url
        }
        $browserUrlBox.Text = $url
        if ($script:browserType -eq "WebView2") {
            if ($webBrowser.CoreWebView2) {
                $webBrowser.CoreWebView2.Navigate($url)
            }
        }
        else {
            $webBrowser.Navigate($url)
        }
    }
}

# Browser Event Handlers
$browserGoBtn.Add_Click({
        Open-Browser $browserUrlBox.Text.Trim()
    })

$browserUrlBox.Add_KeyDown({
        if ($_.KeyCode -eq "Enter") {
            Open-Browser $browserUrlBox.Text.Trim()
        }
    })

$browserBackBtn.Add_Click({
        if ($script:browserType -eq "WebView2") {
            if ($webBrowser.CoreWebView2 -and $webBrowser.CoreWebView2.CanGoBack) {
                $webBrowser.CoreWebView2.GoBack()
            }
        }
        else {
            if ($webBrowser.CanGoBack) {
                $webBrowser.GoBack()
            }
        }
    })

$browserForwardBtn.Add_Click({
        if ($script:browserType -eq "WebView2") {
            if ($webBrowser.CoreWebView2 -and $webBrowser.CoreWebView2.CanGoForward) {
                $webBrowser.CoreWebView2.GoForward()
            }
        }
        else {
            if ($webBrowser.CanGoForward) {
                $webBrowser.GoForward()
            }
        }
    })

$browserRefreshBtn.Add_Click({
        if ($script:browserType -eq "WebView2") {
            if ($webBrowser.CoreWebView2) {
                $webBrowser.CoreWebView2.Reload()
            }
        }
        else {
            $webBrowser.Refresh()
        }
    })

# Update URL box when browser navigates
if ($script:browserType -eq "WebView2") {
    $webBrowser.CoreWebView2InitializationCompleted.Add({
            $webBrowser.CoreWebView2.Add_NavigationCompleted({
                    $browserUrlBox.Text = $webBrowser.CoreWebView2.Source.ToString()
                })
        })
}
else {
    $webBrowser.Add_Navigated({
            $browserUrlBox.Text = $webBrowser.Url.ToString()
        })
}

# Navigate to default URL on load
Start-Job -ScriptBlock {
    Start-Sleep -Seconds 1
} | Out-Null
$form.Add_Shown({
        Open-Browser "https://www.youtube.com"
    })

# ============================================
# Git Functions
# ============================================
function Get-GitStatus {
    $currentDir = if ($global:currentFile) { Split-Path $global:currentFile } else { Get-Location }
    if (-not (Test-Path (Join-Path $currentDir ".git"))) {
        return "Not a Git repository"
    }
    
    try {
        Push-Location $currentDir
        $status = git status --short 2>&1
        $branch = git branch --show-current 2>&1
        $remote = git remote -v 2>&1
        
        $output = "Branch: $branch`r`n`r`n"
        $output += "Status:`r`n$status`r`n`r`n"
        $output += "Remote:`r`n$remote"
        return $output
    }
    catch {
        return "Error: $_"
    }
    finally {
        Pop-Location
    }
}

function Invoke-GitCommand {
    <#
    .SYNOPSIS
        Executes a Git command in the current repository
    .PARAMETER Command
        The Git command to execute
    .PARAMETER Arguments
        Arguments to pass to the Git command
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Command,
        
        [Parameter(Mandatory = $false)]
        [string[]]$Arguments
    )
    
    $currentDir = if ($global:currentFile) { Split-Path $global:currentFile } else { Get-Location }
    if (-not (Test-Path (Join-Path $currentDir ".git"))) {
        return "Not a Git repository"
    }
    
    try {
        Push-Location $currentDir
        $result = & git $Command $Arguments 2>&1 | Out-String
        return $result
    }
    catch {
        return "Error: $_"
    }
    finally {
        Pop-Location
    }
}

function Update-GitStatus {
    $status = Get-GitStatus
    $gitStatusBox.Clear()
    $gitStatusBox.AppendText($status)
}

# ============================================
# Terminal Functions
# ============================================
function Write-TerminalOutput {
    param([string]$text, [string]$color = "Green")
    $terminalOutput.SelectionStart = $terminalOutput.TextLength
    $terminalOutput.SelectionLength = 0
    $terminalOutput.SelectionColor = [System.Drawing.Color]::FromName($color)
    $terminalOutput.AppendText($text)
    $terminalOutput.SelectionColor = $terminalOutput.ForeColor
    $terminalOutput.ScrollToCaret()
}

function Invoke-TerminalCommand {
    param([string]$command)
    
    if (-not $command.Trim()) { return }
    
    Write-TerminalOutput "PS $($global:currentWorkingDir)> $command`r`n" "Cyan"
    
    # Add to history
    $global:terminalHistory += $command
    $global:terminalHistoryIndex = $global:terminalHistory.Count
    
    try {
        # Change directory commands
        if ($command -match "^cd\s+(.+)$") {
            $path = $Matches[1]
            if ($path -eq "..") {
                $global:currentWorkingDir = Split-Path $global:currentWorkingDir
            }
            elseif (Test-Path $path) {
                $global:currentWorkingDir = Resolve-Path $path
            }
            else {
                Write-TerminalOutput "Path not found: $path`r`n" "Red"
                return
            }
            Set-Location $global:currentWorkingDir
            Write-TerminalOutput "`r`n"
            return
        }
        
        # Execute command
        $output = Invoke-Expression $command 2>&1 | Out-String
        Write-TerminalOutput $output
    }
    catch {
        Write-TerminalOutput "Error: $_`r`n" "Red"
    }
}

# ============================================
# Enhanced File Browser Functions
# ============================================
function Update-Explorer {
    Write-StartupLog "Updating file explorer..." "INFO"
    $explorer.Nodes.Clear()
    $currentPath = $global:currentWorkingDir
    
    if (-not $currentPath) {
        $currentPath = Get-Location
        $global:currentWorkingDir = $currentPath
    }
    
    $explorerPathLabel.Text = "Path: $currentPath"
    Write-StartupLog "Current working directory: $currentPath" "INFO"
    
    try {
        # Add drives with better error handling
        $drives = Get-PSDrive -PSProvider FileSystem
        Write-StartupLog "Found $($drives.Count) drives to load" "INFO"
        
        foreach ($drive in $drives) {
            try {
                $driveNode = New-Object System.Windows.Forms.TreeNode("  $($drive.Name):\ ($([math]::Round($drive.Used/1GB,1))GB used)")
                $driveNode.Tag = "$($drive.Root)"
                $driveNode.Name = $drive.Root
                $driveNode.ToolTipText = "Drive $($drive.Name): - Free: $([math]::Round($drive.Free/1GB,1))GB"
                $explorer.Nodes.Add($driveNode) | Out-Null
                
                # Add immediate children with lazy loading (don't load subdirectories)
                try {
                    Add-TreeNodeChildren -parentNode $driveNode -path $driveNode.Tag -showFiles $true -maxItems 500
                    Write-StartupLog "Successfully loaded drive $($drive.Name):" "SUCCESS"
                }
                catch {
                    Write-StartupLog "Warning: Could not fully load drive $($drive.Name): $_" "WARNING"
                    # Add an error indicator but don't fail the whole operation
                    $errorNode = New-Object System.Windows.Forms.TreeNode("‚ö† Access restricted - some items may not be visible")
                    $errorNode.ForeColor = [System.Drawing.Color]::Orange
                    $driveNode.Nodes.Add($errorNode) | Out-Null
                }
            }
            catch {
                Write-StartupLog "Error processing drive $($drive.Name): $_" "ERROR"
            }
        }
        
        # Expand the drive containing current working directory and navigate to it
        if ($global:currentWorkingDir) {
            $currentDrive = [System.IO.Path]::GetPathRoot($global:currentWorkingDir)
            $matchingNode = $explorer.Nodes | Where-Object { $_.Tag -eq $currentDrive }
            if ($matchingNode) {
                $matchingNode.Expand()
                Write-StartupLog "Expanded current drive: $currentDrive" "INFO"
                
                # Try to expand path to current directory
                try {
                    Expand-PathInTree -treeView $explorer -targetPath $global:currentWorkingDir
                }
                catch {
                    Write-StartupLog "Could not navigate to current directory in tree: $_" "WARNING"
                }
            }
        }
        
        Write-StartupLog "File explorer update completed successfully" "SUCCESS"
    }
    catch {
        Write-StartupLog "Critical error in Update-Explorer: $_" "ERROR"
        Write-DevConsole "Error in Update-Explorer: $_" "ERROR"
        
        # Fallback to desktop
        try {
            $desktopPath = [Environment]::GetFolderPath("Desktop")
            $rootNode = New-Object System.Windows.Forms.TreeNode(" Ô∏è Desktop (Fallback)")
            $rootNode.Tag = $desktopPath
            $explorer.Nodes.Add($rootNode) | Out-Null
            Add-TreeNodeChildren -parentNode $rootNode -path $desktopPath -showFiles $true -maxItems 100
            $rootNode.Expand()
            Write-StartupLog "Using desktop fallback: $desktopPath" "WARNING"
        }
        catch {
            Write-StartupLog "Even desktop fallback failed: $_" "ERROR"
        }
    }
}

function Add-TreeNodeChildren {
    param(
        [System.Windows.Forms.TreeNode]$parentNode,
        [string]$path,
        [bool]$showFiles = $true,
        [int]$maxItems = 500,
        [int]$maxDepth = 0
    )
    
    if (-not (Test-Path $path -ErrorAction SilentlyContinue)) { 
        Write-StartupLog "Path does not exist: $path" "WARNING"
        return 
    }
    
    try {
        # Only clear nodes if they are dummy nodes or if explicitly refreshing
        $hasDummyNodes = $parentNode.Nodes | Where-Object { $_.Tag -eq "DUMMY" }
        if ($hasDummyNodes -or $parentNode.Nodes.Count -eq 0) {
            $parentNode.Nodes.Clear()
            Write-StartupLog "Cleared existing nodes for: $path" "DEBUG"
        }
        else {
            Write-StartupLog "Nodes already populated for: $path, skipping" "DEBUG"
            return
        }
        
        # Get directories first, then files with better error handling
        $directories = @()
        $files = @()
        
        try {
            # Use more robust directory enumeration
            $directories = Get-ChildItem -Path $path -Directory -Force -ErrorAction SilentlyContinue | 
            Where-Object { -not ($_.Attributes -band [System.IO.FileAttributes]::System) -or $_.Name -notmatch '^(\$|System Volume Information|pagefile\.sys)' } |
            Sort-Object Name | 
            Select-Object -First $maxItems
            
            Write-StartupLog "Found $($directories.Count) directories in: $path" "DEBUG"
        }
        catch {
            Write-StartupLog "Error reading directories in $path : $_" "WARNING"
        }
        
        if ($showFiles) {
            try {
                $files = Get-ChildItem -Path $path -File -Force -ErrorAction SilentlyContinue | 
                Where-Object { $_.Length -lt 100MB } |  # Skip very large files for performance
                Sort-Object Name | 
                Select-Object -First $maxItems
                
                Write-StartupLog "Found $($files.Count) files in: $path" "DEBUG"
            }
            catch {
                Write-StartupLog "Error reading files in $path : $_" "WARNING"
            }
        }
        
        # Add directories with improved icons and tooltips
        foreach ($dir in $directories) {
            try {
                $isHidden = $dir.Attributes -band [System.IO.FileAttributes]::Hidden
                $isSystem = $dir.Attributes -band [System.IO.FileAttributes]::System
                
                $dirIcon = if ($isHidden) { "üëÅÔ∏è‚Äçüó®Ô∏è" } elseif ($isSystem) { "‚öôÔ∏è" } else { "üìÅ" }
                $dirName = if ($isHidden) { "$($dir.Name) (Hidden)" } else { $dir.Name }
                
                $dirNode = New-Object System.Windows.Forms.TreeNode("$dirIcon $dirName")
                $dirNode.Tag = $dir.FullName
                $dirNode.Name = $dir.FullName
                $dirNode.ToolTipText = "Folder: $($dir.FullName)`nCreated: $($dir.CreationTime)`nAttributes: $($dir.Attributes)"
                
                # Dim hidden/system folders
                if ($isHidden) {
                    $dirNode.ForeColor = [System.Drawing.Color]::Gray
                }
                
                # Add dummy node to show expand arrow for lazy loading
                # Check if directory has subdirectories to decide whether to show expand arrow
                try {
                    $hasSubdirs = Get-ChildItem -Path $dir.FullName -Directory -ErrorAction SilentlyContinue | Select-Object -First 1
                    if ($hasSubdirs) {
                        $dummy = New-Object System.Windows.Forms.TreeNode("Loading...")
                        $dummy.Tag = "DUMMY"
                        $dummy.ForeColor = [System.Drawing.Color]::Gray
                        $dirNode.Nodes.Add($dummy) | Out-Null
                    }
                }
                catch {
                    # If we can't check subdirectories, assume there might be some and add dummy
                    $dummy = New-Object System.Windows.Forms.TreeNode("Loading...")
                    $dummy.Tag = "DUMMY"
                    $dummy.ForeColor = [System.Drawing.Color]::Gray
                    $dirNode.Nodes.Add($dummy) | Out-Null
                }
                
                $parentNode.Nodes.Add($dirNode) | Out-Null
            }
            catch {
                Write-StartupLog "Error processing directory $($dir.Name): $_" "WARNING"
            }
        }
        
        # Add files with better categorization and icons
        foreach ($file in $files) {
            try {
                $fileIcon = Get-FileIcon $file.Extension
                $isHidden = $file.Attributes -band [System.IO.FileAttributes]::Hidden
                $fileName = if ($isHidden) { "$($file.Name) (Hidden)" } else { $file.Name }
                
                $fileNode = New-Object System.Windows.Forms.TreeNode("$fileIcon $fileName")
                $fileNode.Tag = $file.FullName
                $fileNode.Name = $file.FullName
                
                $fileSizeStr = if ($file.Length -gt 1MB) { 
                    "$([math]::Round($file.Length / 1MB, 2)) MB" 
                }
                elseif ($file.Length -gt 1KB) { 
                    "$([math]::Round($file.Length / 1KB, 2)) KB" 
                }
                else { 
                    "$($file.Length) bytes" 
                }
                
                $fileNode.ToolTipText = "File: $($file.FullName)`nSize: $fileSizeStr`nModified: $($file.LastWriteTime)`nAttributes: $($file.Attributes)"
                
                # Enhanced color coding for file types
                if ($file.Extension -match '\.(ps1|bat|cmd|sh)$') {
                    $fileNode.ForeColor = [System.Drawing.Color]::Blue
                }
                elseif ($file.Extension -match '\.(txt|md|log|readme)$') {
                    $fileNode.ForeColor = [System.Drawing.Color]::Green
                }
                elseif ($file.Extension -match '\.(json|xml|yml|yaml|config|ini)$') {
                    $fileNode.ForeColor = [System.Drawing.Color]::Purple
                }
                elseif ($file.Extension -match '\.(js|html|css|py|cs|cpp|c|h|java|php|rb)$') {
                    $fileNode.ForeColor = [System.Drawing.Color]::DarkOrange
                }
                elseif ($file.Extension -match '\.(exe|dll|msi|app)$') {
                    $fileNode.ForeColor = [System.Drawing.Color]::Red
                }
                elseif ($file.Extension -match '\.(jpg|jpeg|png|gif|bmp|ico|svg)$') {
                    $fileNode.ForeColor = [System.Drawing.Color]::Magenta
                }
                elseif ($isHidden) {
                    $fileNode.ForeColor = [System.Drawing.Color]::Gray
                }
                
                $parentNode.Nodes.Add($fileNode) | Out-Null
            }
            catch {
                Write-StartupLog "Error processing file $($file.Name): $_" "WARNING"
            }
        }
        
        # Add summary if items were truncated
        $totalDirs = (Get-ChildItem -Path $path -Directory -Force -ErrorAction SilentlyContinue | Measure-Object).Count
        $totalFiles = if ($showFiles) { (Get-ChildItem -Path $path -File -Force -ErrorAction SilentlyContinue | Measure-Object).Count } else { 0 }
        
        if (($directories.Count + $files.Count) -lt ($totalDirs + $totalFiles)) {
            $truncatedNode = New-Object System.Windows.Forms.TreeNode("‚ãØ ... and $($totalDirs + $totalFiles - $directories.Count - $files.Count) more items")
            $truncatedNode.ForeColor = [System.Drawing.Color]::DarkGray
            $parentNode.Nodes.Add($truncatedNode) | Out-Null
        }
        
        Write-StartupLog "Loaded $($directories.Count) folders and $($files.Count) files for: $path" "DEBUG"
        
    }
    catch {
        Write-StartupLog "Critical error loading children for $path : $_" "ERROR"
        Write-DevConsole "Error loading children for $path : $_" "WARNING"
        $errorNode = New-Object System.Windows.Forms.TreeNode("‚ö† Error loading contents: $($_.Exception.Message)")
        $errorNode.ForeColor = [System.Drawing.Color]::Red
        $errorNode.ToolTipText = "Error details: $_"
        $parentNode.Nodes.Add($errorNode) | Out-Null
    }
}

# Helper function to expand a specific path in the tree view
function Expand-PathInTree {
    param(
        [System.Windows.Forms.TreeView]$treeView,
        [string]$targetPath
    )
    
    try {
        $pathParts = $targetPath.Split([IO.Path]::DirectorySeparatorChar, [StringSplitOptions]::RemoveEmptyEntries)
        $currentPath = ""
        $currentNodes = $treeView.Nodes
        
        foreach ($part in $pathParts) {
            $currentPath = Join-Path $currentPath $part
            $matchingNode = $currentNodes | Where-Object { $_.Tag -eq $currentPath -or $_.Tag -eq "$currentPath\" }
            
            if ($matchingNode) {
                $matchingNode.Expand()
                $currentNodes = $matchingNode.Nodes
            }
            else {
                break
            }
        }
    }
    catch {
        Write-StartupLog "Error expanding path in tree: $_" "WARNING"
    }
}

function Get-FileIcon {
    param([string]$extension)
    
    switch -Regex ($extension.ToLower()) {
        '\.(txt|md|log)$' { return "üìÑ" }
        '\.(ps1|bat|cmd|sh)$' { return "‚ö°" }
        '\.(json|xml|yml|yaml)$' { return "‚öôÔ∏è" }
        '\.(js|html|css)$' { return "üåê" }
        '\.(py|cs|cpp|c|h|java)$' { return "üíª" }
        '\.(jpg|jpeg|png|gif|bmp)$' { return "üñºÔ∏è" }
        '\.(mp3|wav|flac|mp4|avi)$' { return "üéµ" }
        '\.(zip|rar|7z|gz)$' { return "üì¶" }
        '\.(pdf|doc|docx|xls|xlsx)$' { return "üìã" }
        '\.(exe|msi|dll)$' { return "‚öôÔ∏è" }
        default { return "üìÑ" }
    }
}

function Expand-ExplorerNode {
    param($node)
    
    # Don't expand dummy nodes or nodes without tags
    if (-not $node.Tag -or $node.Tag -eq "DUMMY") { 
        Write-DevConsole "Skipping expansion of dummy or invalid node" "DEBUG"
        return 
    }
    
    # Check if this node has dummy children (needs population)
    $hasDummyChild = $node.Nodes | Where-Object { $_.Tag -eq "DUMMY" }
    
    if ($hasDummyChild) {
        # This directory node needs to be populated - remove dummy and add real content
        Write-DevConsole "Expanding directory with dummy child: $($node.Tag)" "DEBUG"
        
        if (Test-Path $node.Tag -PathType Container) {
            try {
                # Clear all existing nodes (including dummy)
                $node.Nodes.Clear()
                
                # Populate with actual directories and files
                Add-TreeNodeChildren -parentNode $node -path $node.Tag -showFiles $true -maxItems 500
                
                Write-DevConsole "Successfully populated node: $($node.Tag) with $($node.Nodes.Count) items" "DEBUG"
            }
            catch {
                Write-DevConsole "Error expanding node $($node.Tag): $_" "ERROR"
                
                # Re-add dummy node if expansion failed
                $dummy = New-Object System.Windows.Forms.TreeNode("Error loading...")
                $dummy.Tag = "DUMMY"
                $dummy.ForeColor = [System.Drawing.Color]::Red
                $node.Nodes.Add($dummy) | Out-Null
            }
        }
        else {
            Write-DevConsole "Path no longer exists: $($node.Tag)" "WARNING"
            $node.Nodes.Clear()
        }
    }
    else {
        Write-DevConsole "Node already expanded or has no dummy children: $($node.Tag)" "DEBUG"
    }
}

# ============================================
# Extension Marketplace Functions
# ============================================
function Register-Extension {
    param(
        [string]$Id,
        [string]$Name,
        [string]$Description,
        [string]$Author,
        [int]$Language,
        [int]$Capabilities,
        [string]$Version = "1.0.0",
        [scriptblock]$EntryPoint = $null
    )
    
    $extension = @{
        Id           = $Id
        Name         = $Name
        Description  = $Description
        Author       = $Author
        Language     = $Language
        Capabilities = $Capabilities
        Version      = $Version
        Enabled      = $true
        Installed    = $true
        EntryPoint   = $EntryPoint
        Hooks        = @{}
    }
    
    $script:extensionRegistry += $extension
    return $extension
}

function Initialize-ExtensionSystem {
    # Register built-in extensions
    Register-Extension -Id "python-lang" -Name "Python Language Support" `
        -Description "Full Python IDE features with syntax highlighting, debugging, and linting" `
        -Author "RawrXD" -Language $script:LANG_PYTHON `
        -Capabilities ($script:CAP_SYNTAX_HIGHLIGHT -bor $script:CAP_CODE_COMPLETION -bor $script:CAP_DEBUGGING -bor $script:CAP_LINTING)
    
    Register-Extension -Id "c-lang" -Name "C/C++ Development" `
        -Description "C and C++ support with GCC/Clang integration" `
        -Author "RawrXD" -Language $script:LANG_C `
        -Capabilities ($script:CAP_SYNTAX_HIGHLIGHT -bor $script:CAP_CODE_COMPLETION -bor $script:CAP_DEBUGGING -bor $script:CAP_BUILD_SYSTEM)
    
    Register-Extension -Id "rust-lang" -Name "Rust Language Support" `
        -Description "Rust development with Cargo integration" `
        -Author "RawrXD" -Language $script:LANG_RUST `
        -Capabilities ($script:CAP_SYNTAX_HIGHLIGHT -bor $script:CAP_CODE_COMPLETION -bor $script:CAP_BUILD_SYSTEM)
    
    Register-Extension -Id "model-dampener" -Name "Model Dampener" `
        -Description "On-the-fly AI model behavior modification without retraining" `
        -Author "RawrXD" -Language $script:LANG_ASM `
        -Capabilities ($script:CAP_MODEL_DAMPENING -bor $script:CAP_AI_ASSIST)
    
    Register-Extension -Id "git-enhanced" -Name "Enhanced Git Integration" `
        -Description "Advanced Git features with visual diff and merge tools" `
        -Author "RawrXD" -Language $script:LANG_ASM `
        -Capabilities $script:CAP_GIT_INTEGRATION
    
    # Load user-installed extensions
    Import-UserExtensions
}

function Import-UserExtensions {
    $extensionsFile = Join-Path $script:extensionsDir "extensions.json"
    if (Test-Path $extensionsFile) {
        try {
            $userExtensions = Get-Content $extensionsFile | ConvertFrom-Json
            foreach ($ext in $userExtensions) {
                Register-Extension -Id $ext.Id -Name $ext.Name -Description $ext.Description `
                    -Author $ext.Author -Language $ext.Language -Capabilities $ext.Capabilities -Version $ext.Version
            }
        }
        catch {
            Write-Host "Error loading user extensions: $_" -ForegroundColor Yellow
        }
    }
}

function Search-Marketplace {
    param([string]$Query, [int]$LanguageFilter = -1)
    
    $results = @()
    foreach ($ext in $script:extensionRegistry) {
        $match = $false
        if ([string]::IsNullOrEmpty($Query)) {
            $match = $true
        }
        elseif ($ext.Name -like "*$Query*" -or $ext.Description -like "*$Query*") {
            $match = $true
        }
        
        if ($match -and ($LanguageFilter -eq -1 -or $ext.Language -eq $LanguageFilter)) {
            $results += $ext
        }
    }
    
    return $results
}

function Show-Marketplace {
    $marketplaceForm = New-Object System.Windows.Forms.Form
    $marketplaceForm.Text = "Extension Marketplace"
    $marketplaceForm.Size = New-Object System.Drawing.Size(800, 600)
    $marketplaceForm.StartPosition = "CenterScreen"
    
    # Search box
    $searchBox = New-Object System.Windows.Forms.TextBox
    $searchBox.Dock = [System.Windows.Forms.DockStyle]::Top
    $searchBox.Height = 30
    $searchBox.Font = New-Object System.Drawing.Font("Segoe UI", 10)
    $marketplaceForm.Controls.Add($searchBox) | Out-Null
    
    # Results list
    $resultsList = New-Object System.Windows.Forms.ListView
    $resultsList.Dock = [System.Windows.Forms.DockStyle]::Fill
    $resultsList.View = [System.Windows.Forms.View]::Details
    $resultsList.Font = New-Object System.Drawing.Font("Segoe UI", 9)
    $resultsList.FullRowSelect = $true
    $resultsList.Columns.Add("Name", 200) | Out-Null
    $resultsList.Columns.Add("Description", 400) | Out-Null
    $resultsList.Columns.Add("Author", 100) | Out-Null
    $resultsList.Columns.Add("Version", 80) | Out-Null
    $marketplaceForm.Controls.Add($resultsList) | Out-Null
    
    # Refresh results
    $refreshResults = {
        $resultsList.Items.Clear()
        $query = $searchBox.Text
        $results = Search-Marketplace -Query $query
        foreach ($ext in $results) {
            $item = New-Object System.Windows.Forms.ListViewItem($ext.Name)
            $item.SubItems.Add($ext.Description) | Out-Null
            $item.SubItems.Add($ext.Author) | Out-Null
            $item.SubItems.Add($ext.Version) | Out-Null
            $item.Tag = $ext
            $resultsList.Items.Add($item) | Out-Null
        }
    }
    
    $searchBox.Add_TextChanged($refreshResults)
    $refreshResults.Invoke()
    
    $marketplaceForm.ShowDialog() | Out-Null
}

function Show-InstalledExtensions {
    $installedForm = New-Object System.Windows.Forms.Form
    $installedForm.Text = "Installed Extensions"
    $installedForm.Size = New-Object System.Drawing.Size(700, 500)
    $installedForm.StartPosition = "CenterScreen"
    
    $listBox = New-Object System.Windows.Forms.ListBox
    $listBox.Dock = [System.Windows.Forms.DockStyle]::Fill
    $listBox.Font = New-Object System.Drawing.Font("Consolas", 9)
    $installedForm.Controls.Add($listBox) | Out-Null
    
    foreach ($ext in $script:extensionRegistry) {
        $status = if ($ext.Enabled) { "[ENABLED]" } else { "[DISABLED]" }
        $listBox.Items.Add("$($ext.Name) | Out-Null $status - $($ext.Description)") | Out-Null
    }
    
    $installedForm.ShowDialog() | Out-Null
}

# ============================================
# Settings Functions
# ============================================
function Get-Settings {
    if (Test-Path $script:settingsPath) {
        try {
            $loadedSettings = Get-Content $script:settingsPath | ConvertFrom-Json
            foreach ($key in $loadedSettings.PSObject.Properties.Name) {
                if ($global:settings.ContainsKey($key)) {
                    $global:settings[$key] = $loadedSettings.$key
                }
            }
            Write-DevConsole "Settings loaded from: $script:settingsPath" "INFO"
            
            # Apply loaded settings
            $script:currentModel = $global:settings.OllamaModel
            Set-EditorSettings
        }
        catch {
            Write-DevConsole "Error loading settings: $_" "ERROR"
        }
    }
}

function Save-Settings {
    try {
        $settingsDir = Split-Path $script:settingsPath
        if (-not (Test-Path $settingsDir)) {
            New-Item -ItemType Directory -Path $settingsDir -Force | Out-Null
        }
        
        $global:settings | ConvertTo-Json -Depth 3 | Out-File $script:settingsPath -Encoding UTF8
        Write-DevConsole "Settings saved to: $script:settingsPath" "SUCCESS"
    }
    catch {
        Write-DevConsole "Error saving settings: $_" "ERROR"
    }
}

function Apply-EditorSettings {
    try {
        $editor.Font = New-Object System.Drawing.Font($global:settings.EditorFontFamily, $global:settings.EditorFontSize)
        Write-DevConsole "Applied editor settings" "DEBUG"
    }
    catch {
        Write-DevConsole "Error applying editor settings: $_" "WARNING"
    }
}

function Get-AvailableModels {
    try {
        $response = Invoke-RestMethod -Uri "http://localhost:11434/api/tags" -Method GET -TimeoutSec 5
        return $response.models | ForEach-Object { $_.name } | Sort-Object
    }
    catch {
        Write-DevConsole "Could not fetch models from Ollama: $_" "WARNING"
        return @("bigdaddyg-fast:latest", "llama3:latest", "phi:latest")  # fallback models
    }
}

function Show-ModelSettings {
    $settingsForm = New-Object System.Windows.Forms.Form
    $settingsForm.Text = "AI Model & General Settings"
    $settingsForm.Size = New-Object System.Drawing.Size(500, 400)
    $settingsForm.StartPosition = "CenterScreen"
    $settingsForm.FormBorderStyle = "FixedDialog"
    $settingsForm.MaximizeBox = $false
    
    # Model selection
    $modelLabel = New-Object System.Windows.Forms.Label
    $modelLabel.Text = "AI Model:"
    $modelLabel.Location = New-Object System.Drawing.Point(20, 30)
    $modelLabel.Size = New-Object System.Drawing.Size(100, 23)
    $settingsForm.Controls.Add($modelLabel)
    
    $modelCombo = New-Object System.Windows.Forms.ComboBox
    $modelCombo.Location = New-Object System.Drawing.Point(130, 27)
    $modelCombo.Size = New-Object System.Drawing.Size(300, 25)
    $modelCombo.DropDownStyle = [System.Windows.Forms.ComboBoxStyle]::DropDownList
    
    # Populate with available models
    $availableModels = Get-AvailableModels
    foreach ($model in $availableModels) {
        $modelCombo.Items.Add($model) | Out-Null
    }
    $modelCombo.Text = $global:settings.OllamaModel
    $settingsForm.Controls.Add($modelCombo)
    
    # Refresh models button
    $refreshBtn = New-Object System.Windows.Forms.Button
    $refreshBtn.Text = "üîÑ"
    $refreshBtn.Location = New-Object System.Drawing.Point(440, 27)
    $refreshBtn.Size = New-Object System.Drawing.Size(30, 25)
    $refreshBtn.Add_Click({
            $modelCombo.Items.Clear()
            $newModels = Get-AvailableModels
            foreach ($model in $newModels) {
                $modelCombo.Items.Add($model) | Out-Null
            }
        })
    $settingsForm.Controls.Add($refreshBtn)
    
    # Max tabs setting
    $tabsLabel = New-Object System.Windows.Forms.Label
    $tabsLabel.Text = "Max Editor Tabs:"
    $tabsLabel.Location = New-Object System.Drawing.Point(20, 70)
    $tabsLabel.Size = New-Object System.Drawing.Size(100, 23)
    $settingsForm.Controls.Add($tabsLabel)
    
    $tabsNumeric = New-Object System.Windows.Forms.NumericUpDown
    $tabsNumeric.Location = New-Object System.Drawing.Point(130, 67)
    $tabsNumeric.Size = New-Object System.Drawing.Size(80, 25)
    $tabsNumeric.Minimum = 1
    $tabsNumeric.Maximum = 100
    $tabsNumeric.Value = $global:settings.MaxTabs
    $settingsForm.Controls.Add($tabsNumeric)
    
    # Auto-save checkbox
    $autoSaveCheck = New-Object System.Windows.Forms.CheckBox
    $autoSaveCheck.Text = "Enable Auto-Save"
    $autoSaveCheck.Location = New-Object System.Drawing.Point(20, 110)
    $autoSaveCheck.Size = New-Object System.Drawing.Size(150, 23)
    $autoSaveCheck.Checked = $global:settings.AutoSaveEnabled
    $settingsForm.Controls.Add($autoSaveCheck)
    
    # Auto-save interval
    $intervalLabel = New-Object System.Windows.Forms.Label
    $intervalLabel.Text = "Auto-Save Interval (sec):"
    $intervalLabel.Location = New-Object System.Drawing.Point(20, 150)
    $intervalLabel.Size = New-Object System.Drawing.Size(140, 23)
    $settingsForm.Controls.Add($intervalLabel)
    
    $intervalNumeric = New-Object System.Windows.Forms.NumericUpDown
    $intervalNumeric.Location = New-Object System.Drawing.Point(170, 147)
    $intervalNumeric.Size = New-Object System.Drawing.Size(80, 25)
    $intervalNumeric.Minimum = 5
    $intervalNumeric.Maximum = 300
    $intervalNumeric.Value = $global:settings.AutoSaveInterval
    $settingsForm.Controls.Add($intervalNumeric)
    
    # Debug mode checkbox
    $debugCheck = New-Object System.Windows.Forms.CheckBox
    $debugCheck.Text = "Enable Debug Mode"
    $debugCheck.Location = New-Object System.Drawing.Point(20, 190)
    $debugCheck.Size = New-Object System.Drawing.Size(150, 23)
    $debugCheck.Checked = $global:settings.DebugMode
    $settingsForm.Controls.Add($debugCheck)
    
    # Buttons panel
    $buttonPanel = New-Object System.Windows.Forms.Panel
    $buttonPanel.Location = New-Object System.Drawing.Point(0, 320)
    $buttonPanel.Size = New-Object System.Drawing.Size(500, 50)
    $buttonPanel.Dock = [System.Windows.Forms.DockStyle]::Bottom
    $settingsForm.Controls.Add($buttonPanel)
    
    $okButton = New-Object System.Windows.Forms.Button
    $okButton.Text = "OK"
    $okButton.Location = New-Object System.Drawing.Point(320, 10)
    $okButton.Size = New-Object System.Drawing.Size(75, 30)
    $okButton.DialogResult = [System.Windows.Forms.DialogResult]::OK
    $buttonPanel.Controls.Add($okButton)
    
    $cancelButton = New-Object System.Windows.Forms.Button
    $cancelButton.Text = "Cancel"
    $cancelButton.Location = New-Object System.Drawing.Point(405, 10)
    $cancelButton.Size = New-Object System.Drawing.Size(75, 30)
    $cancelButton.DialogResult = [System.Windows.Forms.DialogResult]::Cancel
    $buttonPanel.Controls.Add($cancelButton)
    
    if ($settingsForm.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
        # Apply settings
        $global:settings.OllamaModel = $modelCombo.Text
        $global:settings.MaxTabs = $tabsNumeric.Value
        $global:settings.AutoSaveEnabled = $autoSaveCheck.Checked
        $global:settings.AutoSaveInterval = $intervalNumeric.Value
        $global:settings.DebugMode = $debugCheck.Checked
        
        # Update global variables
        $OllamaModel = $global:settings.OllamaModel
        
        Save-Settings
        Write-DevConsole "Settings updated and saved" "SUCCESS"
        
        # Show restart message if model changed
        Write-DevConsole "Settings saved successfully!" "SUCCESS"
    }
    
    $settingsForm.Dispose()
}

function Show-EditorSettings {
    $editorForm = New-Object System.Windows.Forms.Form
    $editorForm.Text = "Editor Settings"
    $editorForm.Size = New-Object System.Drawing.Size(450, 350)
    $editorForm.StartPosition = "CenterScreen"
    $editorForm.FormBorderStyle = "FixedDialog"
    $editorForm.MaximizeBox = $false
    
    # Font family
    $fontLabel = New-Object System.Windows.Forms.Label
    $fontLabel.Text = "Font Family:"
    $fontLabel.Location = New-Object System.Drawing.Point(20, 30)
    $fontLabel.Size = New-Object System.Drawing.Size(100, 23)
    $editorForm.Controls.Add($fontLabel)
    
    $fontCombo = New-Object System.Windows.Forms.ComboBox
    $fontCombo.Location = New-Object System.Drawing.Point(130, 27)
    $fontCombo.Size = New-Object System.Drawing.Size(150, 25)
    $fontCombo.Items.AddRange(@("Consolas", "Courier New", "Monaco", "Lucida Console", "Source Code Pro"))
    $fontCombo.Text = $global:settings.EditorFontFamily
    $editorForm.Controls.Add($fontCombo)
    
    # Font size
    $sizeLabel = New-Object System.Windows.Forms.Label
    $sizeLabel.Text = "Font Size:"
    $sizeLabel.Location = New-Object System.Drawing.Point(300, 30)
    $sizeLabel.Size = New-Object System.Drawing.Size(70, 23)
    $editorForm.Controls.Add($sizeLabel)
    
    $sizeNumeric = New-Object System.Windows.Forms.NumericUpDown
    $sizeNumeric.Location = New-Object System.Drawing.Point(370, 27)
    $sizeNumeric.Size = New-Object System.Drawing.Size(50, 25)
    $sizeNumeric.Minimum = 8
    $sizeNumeric.Maximum = 72
    $sizeNumeric.Value = $global:settings.EditorFontSize
    $editorForm.Controls.Add($sizeNumeric)
    
    # Tab size
    $tabLabel = New-Object System.Windows.Forms.Label
    $tabLabel.Text = "Tab Size:"
    $tabLabel.Location = New-Object System.Drawing.Point(20, 70)
    $tabLabel.Size = New-Object System.Drawing.Size(100, 23)
    $editorForm.Controls.Add($tabLabel)
    
    $tabNumeric = New-Object System.Windows.Forms.NumericUpDown
    $tabNumeric.Location = New-Object System.Drawing.Point(130, 67)
    $tabNumeric.Size = New-Object System.Drawing.Size(50, 25)
    $tabNumeric.Minimum = 1
    $tabNumeric.Maximum = 8
    $tabNumeric.Value = $global:settings.TabSize
    $editorForm.Controls.Add($tabNumeric)
    
    # Checkboxes
    $lineNumbersCheck = New-Object System.Windows.Forms.CheckBox
    $lineNumbersCheck.Text = "Show Line Numbers"
    $lineNumbersCheck.Location = New-Object System.Drawing.Point(20, 110)
    $lineNumbersCheck.Size = New-Object System.Drawing.Size(150, 23)
    $lineNumbersCheck.Checked = $global:settings.ShowLineNumbers
    $editorForm.Controls.Add($lineNumbersCheck)
    
    $wrapCheck = New-Object System.Windows.Forms.CheckBox
    $wrapCheck.Text = "Word Wrap"
    $wrapCheck.Location = New-Object System.Drawing.Point(200, 110)
    $wrapCheck.Size = New-Object System.Drawing.Size(150, 23)
    $wrapCheck.Checked = $global:settings.WrapText
    $editorForm.Controls.Add($wrapCheck)
    
    $autoIndentCheck = New-Object System.Windows.Forms.CheckBox
    $autoIndentCheck.Text = "Auto Indent"
    $autoIndentCheck.Location = New-Object System.Drawing.Point(20, 150)
    $autoIndentCheck.Size = New-Object System.Drawing.Size(150, 23)
    $autoIndentCheck.Checked = $global:settings.AutoIndent
    $editorForm.Controls.Add($autoIndentCheck)
    
    $highlightCheck = New-Object System.Windows.Forms.CheckBox
    $highlightCheck.Text = "Syntax Highlighting"
    $highlightCheck.Location = New-Object System.Drawing.Point(200, 150)
    $highlightCheck.Size = New-Object System.Drawing.Size(150, 23)
    $highlightCheck.Checked = $global:settings.CodeHighlighting
    $editorForm.Controls.Add($highlightCheck)
    
    # Buttons
    $buttonPanel = New-Object System.Windows.Forms.Panel
    $buttonPanel.Location = New-Object System.Drawing.Point(0, 270)
    $buttonPanel.Size = New-Object System.Drawing.Size(450, 50)
    $buttonPanel.Dock = [System.Windows.Forms.DockStyle]::Bottom
    $editorForm.Controls.Add($buttonPanel)
    
    $okButton = New-Object System.Windows.Forms.Button
    $okButton.Text = "OK"
    $okButton.Location = New-Object System.Drawing.Point(270, 10)
    $okButton.Size = New-Object System.Drawing.Size(75, 30)
    $okButton.DialogResult = [System.Windows.Forms.DialogResult]::OK
    $buttonPanel.Controls.Add($okButton)
    
    $cancelButton = New-Object System.Windows.Forms.Button
    $cancelButton.Text = "Cancel"
    $cancelButton.Location = New-Object System.Drawing.Point(355, 10)
    $cancelButton.Size = New-Object System.Drawing.Size(75, 30)
    $cancelButton.DialogResult = [System.Windows.Forms.DialogResult]::Cancel
    $buttonPanel.Controls.Add($cancelButton)
    
    if ($editorForm.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) {
        # Apply settings
        $global:settings.EditorFontFamily = $fontCombo.Text
        $global:settings.EditorFontSize = $sizeNumeric.Value
        $global:settings.TabSize = $tabNumeric.Value
        $global:settings.ShowLineNumbers = $lineNumbersCheck.Checked
        $global:settings.WrapText = $wrapCheck.Checked
        $global:settings.AutoIndent = $autoIndentCheck.Checked
        $global:settings.CodeHighlighting = $highlightCheck.Checked
        
        Apply-EditorSettings
        Save-Settings
        Write-DevConsole "Editor settings updated and applied" "SUCCESS"
    }
    
    $editorForm.Dispose()
}

# ============================================
# Command Palette Functions
# ============================================
function Show-CommandPalette {
    $commandPalette.Show()
    $paletteInput.Focus()
    $paletteInput.SelectAll()
    Update-CommandPalette
}

function Hide-CommandPalette {
    $commandPalette.Hide()
}

function Update-CommandPalette {
    $query = $paletteInput.Text.ToLower()
    $paletteResults.Items.Clear()
    
    if ([string]::IsNullOrWhiteSpace($query)) {
        $paletteLabel.Text = "Type a command or search extensions..."
        return
    }
    
    # Command list
    $commands = @(
        @{Name = "> Git: Status"; Action = { Update-GitStatus; $rightTabControl.SelectedTab = $gitTab } }
        @{Name = "> Git: Add All"; Action = { Invoke-GitCommand "add" @("."); Update-GitStatus } }
        @{Name = "> Git: Commit"; Action = { $msg = [Microsoft.VisualBasic.Interaction]::InputBox("Commit message:", "Git Commit"); if ($msg) { Invoke-GitCommand "commit" @("-m", $msg); Update-GitStatus } } }
        @{Name = "> Git: Push"; Action = { Invoke-GitCommand "push" @(); Update-GitStatus } }
        @{Name = "> Git: Pull"; Action = { Invoke-GitCommand "pull" @(); Update-GitStatus } }
        @{Name = "> File: Open"; Action = { $openItem.PerformClick() } }
        @{Name = "> File: Save"; Action = { $saveItem.PerformClick() } }
        @{Name = "> File: Save As"; Action = { $saveAsItem.PerformClick() } }
        @{Name = "> Terminal: Focus"; Action = { $rightTabControl.SelectedTab = $terminalTab } }
        @{Name = "> Browser: Focus"; Action = { $rightTabControl.SelectedTab = $browserTab } }
        @{Name = "> Chat: Focus"; Action = { $rightTabControl.SelectedTab = $chatTab } }
        @{Name = "> Extensions: Marketplace"; Action = { Show-Marketplace } }
        @{Name = "> Extensions: Installed"; Action = { Show-InstalledExtensions } }
        @{Name = "> Agent: Toggle Mode"; Action = { $toggle.PerformClick() } }
        @{Name = "> Code: Generate"; Action = { $chatBox.AppendText("Use /code <description> in chat`r`n"); $rightTabControl.SelectedTab = $chatTab } }
        @{Name = "> Code: Review"; Action = { $chatBox.AppendText("Use /review in chat`r`n"); $rightTabControl.SelectedTab = $chatTab } }
        @{Name = "> Agent: Start Workflow"; Action = { $chatBox.AppendText("Use /workflow <goal> in chat`r`n"); $rightTabControl.SelectedTab = $chatTab } }
        @{Name = "> Agent: List Tools"; Action = { $chatBox.AppendText("Use /tools in chat`r`n"); $rightTabControl.SelectedTab = $chatTab } }
        @{Name = "> Agent: Environment Info"; Action = { $chatBox.AppendText("Use /env in chat`r`n"); $rightTabControl.SelectedTab = $chatTab } }
        @{Name = "> Agent: Tasks Panel"; Action = { $rightTabControl.SelectedTab = $agentTasksTab } }
    )
    
    # Extension search
    $extensions = Search-Marketplace -Query $query
    foreach ($ext in $extensions) {
        $commands += @{Name = "Extension: $($ext.Name)"; Action = { $chatBox.AppendText("Extension: $($ext.Name) - $($ext.Description)`r`n"); $rightTabControl.SelectedTab = $chatTab } }
    }
    
    # Filter and add matching commands
    $matching = $commands | Where-Object { $_.Name.ToLower() -like "*$query*" }
    foreach ($cmd in $matching) {
        $paletteResults.Items.Add($cmd.Name) | Out-Null
    }
    
    if ($paletteResults.Items.Count -gt 0) {
        $paletteResults.SelectedIndex = 0
        $paletteLabel.Text = "$($paletteResults.Items.Count) result(s) found"
    }
    else {
        $paletteLabel.Text = "No commands found"
    }
}

function Invoke-CommandPaletteSelection {
    $selected = $paletteResults.SelectedItem
    if ($selected) {
        $query = $paletteInput.Text.ToLower()
        $commands = @(
            @{Name = "> Git: Status"; Action = { Update-GitStatus; $rightTabControl.SelectedTab = $gitTab } }
            @{Name = "> Git: Add All"; Action = { Invoke-GitCommand "add" @("."); Update-GitStatus } }
            @{Name = "> Git: Commit"; Action = { $msg = [Microsoft.VisualBasic.Interaction]::InputBox("Commit message:", "Git Commit"); if ($msg) { Invoke-GitCommand "commit" @("-m", $msg); Update-GitStatus } } }
            @{Name = "> Git: Push"; Action = { Invoke-GitCommand "push" @(); Update-GitStatus } }
            @{Name = "> Git: Pull"; Action = { Invoke-GitCommand "pull" @(); Update-GitStatus } }
            @{Name = "> File: Open"; Action = { $openItem.PerformClick() } }
            @{Name = "> File: Save"; Action = { $saveItem.PerformClick() } }
            @{Name = "> File: Save As"; Action = { $saveAsItem.PerformClick() } }
            @{Name = "> Terminal: Focus"; Action = { $rightTabControl.SelectedTab = $terminalTab } }
            @{Name = "> Browser: Focus"; Action = { $rightTabControl.SelectedTab = $browserTab } }
            @{Name = "> Chat: Focus"; Action = { $rightTabControl.SelectedTab = $chatTab } }
            @{Name = "> Extensions: Marketplace"; Action = { Show-Marketplace } }
            @{Name = "> Extensions: Installed"; Action = { Show-InstalledExtensions } }
            @{Name = "> Agent: Toggle Mode"; Action = { $toggle.PerformClick() } }
            @{Name = "> Code: Generate"; Action = { $chatBox.AppendText("Use /code <description> in chat`r`n"); $rightTabControl.SelectedTab = $chatTab } }
            @{Name = "> Code: Review"; Action = { $chatBox.AppendText("Use /review in chat`r`n"); $rightTabControl.SelectedTab = $chatTab } }
        )
        
        $extensions = Search-Marketplace -Query $query
        foreach ($ext in $extensions) {
            $commands += @{Name = "Extension: $($ext.Name)"; Action = { $chatBox.AppendText("Extension: $($ext.Name) - $($ext.Description)`r`n"); $rightTabControl.SelectedTab = $chatTab } }
        }
        
        $cmd = $commands | Where-Object { $_.Name -eq $selected } | Select-Object -First 1
        if ($cmd) {
            Hide-CommandPalette
            $cmd.Action.Invoke()
        }
    }
}

# ============================================
# Agentic Tool-Calling API (Copilot/Amazon Q Compatible)
# ============================================
function Register-AgentTool {
    param(
        [string]$Name,
        [string]$Description,
        [hashtable]$Parameters,
        [scriptblock]$Handler
    )
    
    if (-not $script:agentTools) {
        $script:agentTools = @{}
    }
    
    $script:agentTools[$Name] = @{
        Name        = $Name
        Description = $Description
        Parameters  = $Parameters
        Handler     = $Handler
    }
}

function Invoke-AgentTool {
    param(
        [string]$ToolName,
        [hashtable]$Arguments
    )
    
    if ($script:agentTools -and $script:agentTools[$ToolName]) {
        $tool = $script:agentTools[$ToolName]
        try {
            $result = & $tool.Handler @Arguments
            $global:agentContext.Commands += @{
                Tool      = $ToolName
                Arguments = $Arguments
                Result    = $result
                Timestamp = Get-Date
            }
            return $result
        }
        catch {
            return @{Error = $_.Exception.Message }
        }
    }
    return @{Error = "Tool not found: $ToolName" }
}

function Get-AgentToolsSchema {
    <#
    .SYNOPSIS
        Returns the schema of all registered agent tools
    .DESCRIPTION
        Provides a comprehensive list of available tools with their parameters and descriptions
        Compatible with OpenAI function calling and agentic frameworks
    #>
    [CmdletBinding()]
    param()
    
    $tools = @()
    foreach ($tool in $script:agentTools.Values) {
        $tools += @{
            name        = $tool.Name
            description = $tool.Description
            parameters  = $tool.Parameters
            category    = $tool.Category
            version     = $tool.Version
        }
    }
    return $tools
}

# ============================================
# CORE FILE SYSTEM TOOLS
# ============================================

Register-AgentTool -Name "read_file" -Description "Read contents of a file from disk" `
    -Category "FileSystem" -Version "1.0" `
    -Parameters @{
    path = @{
        type        = "string"
        description = "Absolute or relative file path to read"
        required    = $true
    }
} `
    -Handler {
    param([string]$path)
    try {
        if (-not (Test-Path $path)) {
            $fullPath = Join-Path $global:currentWorkingDir $path
            if (Test-Path $fullPath) {
                $path = $fullPath
            }
        }
        
        if (Test-Path $path) {
            $content = [System.IO.File]::ReadAllText($path)
            $fileInfo = Get-Item $path
            return @{
                success    = $true
                content    = $content
                path       = $path
                size_bytes = $fileInfo.Length
                modified   = $fileInfo.LastWriteTime.ToString()
            }
        }
        return @{success = $false; error = "File not found: $path" }
    }
    catch {
        return @{success = $false; error = $_.Exception.Message }
    }
}

Register-AgentTool -Name "write_file" -Description "Write or create a file with content" `
    -Category "FileSystem" -Version "1.0" `
    -Parameters @{
    path    = @{
        type        = "string"
        description = "File path to write (creates if doesn't exist)"
        required    = $true
    }
    content = @{
        type        = "string"
        description = "Content to write to the file"
        required    = $true
    }
    append  = @{
        type        = "boolean"
        description = "Append to file instead of overwriting"
        required    = $false
    }
} `
    -Handler {
    param([string]$path, [string]$content, [bool]$append = $false)
    try {
        if ($append) {
            [System.IO.File]::AppendAllText($path, $content)
        }
        else {
            [System.IO.File]::WriteAllText($path, $content)
        }
        $fileInfo = Get-Item $path
        return @{
            success    = $true
            path       = $path
            size_bytes = $fileInfo.Length
            operation  = if ($append) { "appended" } else { "written" }
        }
    }
    catch {
        return @{success = $false; error = $_.Exception.Message }
    }
}

Register-AgentTool -Name "list_directory" -Description "List all files and folders in a directory" `
    -Category "FileSystem" -Version "1.0" `
    -Parameters @{
    path      = @{
        type        = "string"
        description = "Directory path to list"
        required    = $true
    }
    recursive = @{
        type        = "boolean"
        description = "List files recursively"
        required    = $false
    }
    filter    = @{
        type        = "string"
        description = "File filter pattern (e.g., *.js)"
        required    = $false
    }
} `
    -Handler {
    param([string]$path, [bool]$recursive = $false, [string]$filter = "*")
    try {
        if (Test-Path $path) {
            $items = Get-ChildItem -Path $path -Filter $filter -Recurse:$recursive
            $files = @()
            $directories = @()
            
            foreach ($item in $items) {
                if ($item.PSIsContainer) {
                    $directories += @{
                        name     = $item.Name
                        path     = $item.FullName
                        modified = $item.LastWriteTime.ToString()
                    }
                }
                else {
                    $files += @{
                        name     = $item.Name
                        path     = $item.FullName
                        size     = $item.Length
                        modified = $item.LastWriteTime.ToString()
                    }
                }
            }
            
            return @{
                success     = $true
                path        = $path
                files       = $files
                directories = $directories
                total_files = $files.Count
                total_dirs  = $directories.Count
            }
        }
        return @{success = $false; error = "Directory not found: $path" }
    }
    catch {
        return @{success = $false; error = $_.Exception.Message }
    }
}

Register-AgentTool -Name "create_directory" -Description "Create a new directory" `
    -Category "FileSystem" -Version "1.0" `
    -Parameters @{
    path = @{
        type        = "string"
        description = "Directory path to create"
        required    = $true
    }
} `
    -Handler {
    param([string]$path)
    try {
        if (-not (Test-Path $path)) {
            $null = New-Item -ItemType Directory -Path $path -Force
            return @{success = $true; path = $path; created = $true }
        }
        return @{success = $true; path = $path; created = $false; message = "Directory already exists" }
    }
    catch {
        return @{success = $false; error = $_.Exception.Message }
    }
}

Register-AgentTool -Name "delete_file" -Description "Delete a file from disk" `
    -Category "FileSystem" -Version "1.0" `
    -Parameters @{
    path = @{
        type        = "string"
        description = "File path to delete"
        required    = $true
    }
} `
    -Handler {
    param([string]$path)
    try {
        if (Test-Path $path) {
            Remove-Item -Path $path -Force
            return @{success = $true; path = $path; deleted = $true }
        }
        return @{success = $false; error = "File not found: $path" }
    }
    catch {
        return @{success = $false; error = $_.Exception.Message }
    }
}

# ============================================
# TERMINAL & EXECUTION TOOLS
# ============================================

Register-AgentTool -Name "execute_command" -Description "Execute a shell command in terminal" `
    -Category "Terminal" -Version "1.0" `
    -Parameters @{
    command           = @{
        type        = "string"
        description = "Command to execute"
        required    = $true
    }
    working_directory = @{
        type        = "string"
        description = "Working directory for command execution"
        required    = $false
    }
    timeout_seconds   = @{
        type        = "integer"
        description = "Command timeout in seconds"
        required    = $false
    }
} `
    -Handler {
    param([string]$command, [string]$working_directory = $null, [int]$timeout_seconds = 30)
    try {
        $originalLocation = Get-Location
        if ($working_directory) {
            Set-Location $working_directory
        }
        
        $output = Invoke-Expression $command 2>&1 | Out-String
        $exitCode = $LASTEXITCODE
        
        if ($working_directory) {
            Set-Location $originalLocation
        }
        
        return @{
            success   = ($exitCode -eq 0)
            output    = $output
            exit_code = $exitCode
            command   = $command
        }
    }
    catch {
        if ($working_directory) {
            Set-Location $originalLocation
        }
        return @{success = $false; error = $_.Exception.Message }
    }
}

# ============================================
# GIT VERSION CONTROL TOOLS
# ============================================

Register-AgentTool -Name "git_status" -Description "Get Git repository status" `
    -Category "Git" -Version "1.0" `
    -Parameters @{
    repository_path = @{
        type        = "string"
        description = "Path to Git repository"
        required    = $false
    }
} `
    -Handler {
    param([string]$repository_path = $null)
    try {
        $repoPath = if ($repository_path) { $repository_path } else { $global:currentWorkingDir }
        $originalLocation = Get-Location
        Set-Location $repoPath
        
        $status = git status --short 2>&1
        $branch = git branch --show-current 2>&1
        $remote = git remote -v 2>&1
        
        Set-Location $originalLocation
        
        return @{
            success = $true
            branch  = $branch
            status  = $status
            remote  = $remote
            path    = $repoPath
        }
    }
    catch {
        Set-Location $originalLocation
        return @{success = $false; error = $_.Exception.Message }
    }
}

Register-AgentTool -Name "git_commit" -Description "Commit changes to Git repository" `
    -Category "Git" -Version "1.0" `
    -Parameters @{
    message         = @{
        type        = "string"
        description = "Commit message"
        required    = $true
    }
    repository_path = @{
        type        = "string"
        description = "Path to Git repository"
        required    = $false
    }
} `
    -Handler {
    param([string]$message, [string]$repository_path = $null)
    try {
        $path = if ($repository_path) { $repository_path } else { $global:currentWorkingDir }
        $result = Invoke-GitCommand -Command "commit" -Arguments @("-m", $message)
        return @{success = $true; message = $message; output = $result }
    }
    catch {
        return @{success = $false; error = $_.Exception.Message }
    }
}

# ============================================
# BROWSER & WEB TOOLS
# ============================================

Register-AgentTool -Name "browse_url" -Description "Navigate browser to a URL" `
    -Category "Browser" -Version "1.0" `
    -Parameters @{
    url = @{
        type        = "string"
        description = "URL to navigate to"
        required    = $true
    }
} `
    -Handler {
    param([string]$url)
    try {
        Open-Browser $url
        return @{success = $true; url = $url; navigated = $true }
    }
    catch {
        return @{success = $false; error = $_.Exception.Message }
    }
}

Register-AgentTool -Name "search_web" -Description "Search the web using Google" `
    -Category "Browser" -Version "1.0" `
    -Parameters @{
    query = @{
        type        = "string"
        description = "Search query"
        required    = $true
    }
} `
    -Handler {
    param([string]$query)
    try {
        $encodedQuery = [System.Uri]::EscapeDataString($query)
        $searchUrl = "https://www.google.com/search?q=$encodedQuery"
        Open-Browser $searchUrl
        return @{success = $true; query = $query; url = $searchUrl }
    }
    catch {
        return @{success = $false; error = $_.Exception.Message }
    }
}

# ============================================
# CODE EDITING TOOLS
# ============================================

Register-AgentTool -Name "apply_edit" -Description "Apply structured code edits with diff preview" `
    -Category "CodeEdit" -Version "1.0" `
    -Parameters @{
    file  = @{
        type        = "string"
        description = "File to edit"
        required    = $true
    }
    edits = @{
        type        = "array"
        description = "Array of edit operations with line numbers and content"
        required    = $true
    }
} `
    -Handler {
    param([string]$file, [array]$edits)
    return Set-StructuredEdit -File $file -Edits $edits
}

Register-AgentTool -Name "get_dependencies" -Description "Analyze project dependencies" `
    -Category "Project" -Version "1.0" `
    -Parameters @{
    project_path = @{
        type        = "string"
        description = "Project root path"
        required    = $true
    }
} `
    -Handler {
    param([string]$project_path)
    return Get-ProjectDependencies -Path $project_path
}

Register-AgentTool -Name "get_environment" -Description "Get development environment info" `
    -Category "System" -Version "1.0" `
    -Parameters @{} `
    -Handler {
    param()
    try {
        return @{
            success            = $true
            os                 = [System.Environment]::OSVersion.ToString()
            powershell_version = $PSVersionTable.PSVersion.ToString()
            current_dir        = $global:currentWorkingDir
            user               = $env:USERNAME
            computer           = $env:COMPUTERNAME
            dotnet_installed   = (Get-Command dotnet -ErrorAction SilentlyContinue) -ne $null
            git_installed      = (Get-Command git -ErrorAction SilentlyContinue) -ne $null
            node_installed     = (Get-Command node -ErrorAction SilentlyContinue) -ne $null
            python_installed   = (Get-Command python -ErrorAction SilentlyContinue) -ne $null
        }
    }
    catch {
        return @{success = $false; error = $_.Exception.Message }
    }
}

# Enhanced Browser Automation Tools
Register-AgentTool -Name "browser_search_dependency" -Description "Search for missing dependencies and get download links" `
    -Category "Browser" -Version "1.0" `
    -Parameters @{
    dependency_name = @{
        type        = "string"
        description = "Name of the missing dependency (e.g., 'numpy', 'lodash', 'boost')"
        required    = $true
    }
    language        = @{
        type        = "string" 
        description = "Programming language context (python, javascript, cpp, etc.)"
        required    = $false
    }
} `
    -Handler {
    param([string]$dependency_name, [string]$language = "")
    
    try {
        $searchQuery = "$dependency_name"
        if ($language) {
            $searchQuery += " $language package download install"
        }
        else {
            $searchQuery += " package library download"
        }
        
        $encodedQuery = [System.Web.HttpUtility]::UrlEncode($searchQuery)
        $searchUrl = "https://www.google.com/search?q=$encodedQuery"
        
        # Navigate browser to search results
        if ($script:useWebView2 -and $global:webView2) {
            $global:webView2.CoreWebView2.Navigate($searchUrl)
        }
        elseif ($global:browser) {
            $global:browser.Navigate($searchUrl)
        }
        
        # Return suggested package managers based on language
        $suggestions = @()
        switch ($language.ToLower()) {
            "python" { 
                $suggestions += "pip install $dependency_name"
                $suggestions += "conda install $dependency_name" 
                $pypiUrl = "https://pypi.org/search/?q=$dependency_name"
                if ($script:useWebView2 -and $global:webView2) {
                    Start-Sleep 2
                    $global:webView2.CoreWebView2.Navigate($pypiUrl)
                }
            }
            "javascript" { 
                $suggestions += "npm install $dependency_name"
                $suggestions += "yarn add $dependency_name"
                $npmUrl = "https://www.npmjs.com/search?q=$dependency_name"
                if ($script:useWebView2 -and $global:webView2) {
                    Start-Sleep 2
                    $global:webView2.CoreWebView2.Navigate($npmUrl)
                }
            }
            "cpp" { 
                $suggestions += "vcpkg install $dependency_name"
                $suggestions += "conan install $dependency_name"
            }
            "rust" {
                $suggestions += "cargo add $dependency_name"
                $cratesUrl = "https://crates.io/search?q=$dependency_name"
                if ($script:useWebView2 -and $global:webView2) {
                    Start-Sleep 2
                    $global:webView2.CoreWebView2.Navigate($cratesUrl)
                }
            }
            "go" {
                $suggestions += "go get $dependency_name"
            }
            "dotnet" {
                $suggestions += "dotnet add package $dependency_name"
                $nugetUrl = "https://www.nuget.org/packages?q=$dependency_name"
                if ($script:useWebView2 -and $global:webView2) {
                    Start-Sleep 2
                    $global:webView2.CoreWebView2.Navigate($nugetUrl)
                }
            }
        }
        
        return @{
            success     = $true
            dependency  = $dependency_name
            language    = $language
            search_url  = $searchUrl
            suggestions = $suggestions
            message     = "Browser navigated to search results for '$dependency_name'. Check browser tab for download links."
        }
    }
    catch {
        return @{success = $false; error = $_.Exception.Message }
    }
}

Register-AgentTool -Name "extract_webpage_content" -Description "Extract text content from current webpage for analysis" `
    -Category "Browser" -Version "1.0" `
    -Parameters @{
    extract_links = @{
        type        = "boolean"
        description = "Whether to extract download links from the page"
        required    = $false
    }
} `
    -Handler {
    param([bool]$extract_links = $false)
    
    try {
        $content = @{
            title = ""
            text  = ""
            links = @()
            url   = ""
        }
        
        if ($script:useWebView2 -and $global:webView2) {
            $content.url = $global:webView2.CoreWebView2.Source
            $content.title = $global:webView2.CoreWebView2.DocumentTitle
            
            if ($extract_links) {
                # JavaScript to extract download links
                $jsCode = @"
                Array.from(document.links)
                    .filter(link => link.href.match(/\.(exe|msi|zip|tar\.gz|deb|rpm|dmg|pkg|whl)$/i) || 
                                  link.href.includes('download') || 
                                  link.href.includes('install') ||
                                  link.textContent.toLowerCase().includes('download'))
                    .map(link => ({
                        text: link.textContent.trim(),
                        href: link.href,
                        type: link.href.split('.').pop()
                    }))
                    .slice(0, 10)
"@
                # Note: In real implementation, you'd use ExecuteScriptAsync
                $content.links = @("Manual extraction required - check browser for download links")
            }
        }
        
        return @{
            success = $true
            content = $content
            message = "Webpage content extracted. Current URL: $($content.url)"
        }
    }
    catch {
        return @{success = $false; error = $_.Exception.Message }
    }
}

Register-AgentTool -Name "check_package_installed" -Description "Check if a package/dependency is already installed" `
    -Category "System" -Version "1.0" `
    -Parameters @{
    package_name = @{
        type        = "string"
        description = "Name of the package to check"
        required    = $true
    }
    language     = @{
        type        = "string"
        description = "Language/package manager context"
        required    = $true
    }
} `
    -Handler {
    param([string]$package_name, [string]$language)
    
    try {
        $installed = $false
        $version = ""
        $command = ""
        
        switch ($language.ToLower()) {
            "python" {
                $command = "pip show $package_name"
                try {
                    $result = pip show $package_name 2>$null
                    if ($LASTEXITCODE -eq 0) {
                        $installed = $true
                        $version = ($result | Where-Object { $_ -like "Version:*" }) -replace "Version: ", ""
                    }
                }
                catch { }
            }
            "javascript" {
                $command = "npm list $package_name"
                try {
                    $result = npm list $package_name --depth=0 2>$null
                    $installed = $LASTEXITCODE -eq 0
                }
                catch { }
            }
            "dotnet" {
                $command = "dotnet list package"
                try {
                    $result = dotnet list package | Select-String $package_name
                    $installed = $result.Count -gt 0
                }
                catch { }
            }
            "powershell" {
                $command = "Get-Module -ListAvailable $package_name"
                try {
                    $module = Get-Module -ListAvailable $package_name -ErrorAction SilentlyContinue
                    if ($module) {
                        $installed = $true
                        $version = $module[0].Version.ToString()
                    }
                }
                catch { }
            }
        }
        
        return @{
            success       = $true
            package       = $package_name
            language      = $language
            installed     = $installed
            version       = $version
            check_command = $command
        }
    }
    catch {
        return @{success = $false; error = $_.Exception.Message }
    }
}

Register-AgentTool -Name "auto_install_dependency" -Description "Automatically install missing dependencies" `
    -Category "System" -Version "1.0" `
    -Parameters @{
    package_name = @{
        type        = "string"
        description = "Name of the package to install"
        required    = $true
    }
    language     = @{
        type        = "string"
        description = "Language/package manager to use"
        required    = $true
    }
    auto_confirm = @{
        type        = "boolean"
        description = "Whether to auto-confirm installation"
        required    = $false
    }
} `
    -Handler {
    param([string]$package_name, [string]$language, [bool]$auto_confirm = $false)
    
    try {
        $installCommand = ""
        $success = $false
        
        switch ($language.ToLower()) {
            "python" {
                $installCommand = "pip install $package_name"
            }
            "javascript" {
                $installCommand = "npm install $package_name"
            }
            "dotnet" {
                $installCommand = "dotnet add package $package_name"
            }
            "rust" {
                $installCommand = "cargo add $package_name"
            }
            "powershell" {
                $installCommand = "Install-Module -Name $package_name -Force"
            }
        }
        
        if ($installCommand) {
            if ($auto_confirm) {
                try {
                    $output = Invoke-Expression $installCommand 2>&1
                    $success = $LASTEXITCODE -eq 0
                    
                    return @{
                        success  = $success
                        package  = $package_name
                        language = $language
                        command  = $installCommand
                        output   = $output -join "`n"
                        message  = if ($success) { "Successfully installed $package_name" } else { "Installation failed" }
                    }
                }
                catch {
                    return @{success = $false; error = $_.Exception.Message; command = $installCommand }
                }
            }
            else {
                return @{
                    success  = $true
                    package  = $package_name
                    language = $language
                    command  = $installCommand
                    message  = "Installation command prepared: $installCommand (run with auto_confirm=true to execute)"
                }
            }
        }
        else {
            return @{success = $false; error = "Unsupported language/package manager: $language" }
        }
    }
    catch {
        return @{success = $false; error = $_.Exception.Message }
    }
}

Register-AgentTool -Name "analyze_code_errors" -Description "Analyze code for syntax errors and suggest fixes" `
    -Category "Code" -Version "1.0" `
    -Parameters @{
    file_path = @{
        type        = "string"
        description = "Path to the code file to analyze"
        required    = $true
    }
    language  = @{
        type        = "string"
        description = "Programming language of the code"
        required    = $false
    }
} `
    -Handler {
    param([string]$file_path, [string]$language = "")
    
    try {
        if (-not (Test-Path $file_path)) {
            return @{success = $false; error = "File not found: $file_path" }
        }
        
        $content = Get-Content $file_path -Raw
        $errors = @()
        $suggestions = @()
        
        # Detect language if not provided
        if (-not $language) {
            $extension = [System.IO.Path]::GetExtension($file_path).ToLower()
            switch ($extension) {
                ".py" { $language = "python" }
                ".js" { $language = "javascript" }
                ".ps1" { $language = "powershell" }
                ".cs" { $language = "csharp" }
                ".cpp" { $language = "cpp" }
                ".c" { $language = "c" }
            }
        }
        
        # Language-specific error checking
        switch ($language.ToLower()) {
            "python" {
                # Check for common Python issues
                if ($content -match "import (\w+)") {
                    $imports = [regex]::Matches($content, "import (\w+)") | ForEach-Object { $_.Groups[1].Value }
                    foreach ($import in $imports) {
                        try {
                            python -c "import $import" 2>$null
                            if ($LASTEXITCODE -ne 0) {
                                $errors += "Missing import: $import"
                                $suggestions += "Install with: pip install $import"
                            }
                        }
                        catch { }
                    }
                }
            }
            "powershell" {
                # PowerShell syntax check
                try {
                    $null = [System.Management.Automation.PSParser]::Tokenize($content, [ref]$null)
                }
                catch {
                    $errors += "PowerShell syntax error: $($_.Exception.Message)"
                }
            }
            "javascript" {
                # Check for common JS issues
                if ($content -match "require\(['""]([^'""]+)['""\)]") {
                    $requires = [regex]::Matches($content, "require\(['""]([^'""]+)['""\)]") | ForEach-Object { $_.Groups[1].Value }
                    foreach ($req in $requires) {
                        if (-not (Test-Path "node_modules\$req") -and -not $req.StartsWith(".")) {
                            $errors += "Missing module: $req"
                            $suggestions += "Install with: npm install $req"
                        }
                    }
                }
            }
        }
        
        return @{
            success     = $true
            file        = $file_path
            language    = $language
            errors      = $errors
            suggestions = $suggestions
            message     = "Analysis complete. Found $($errors.Count) potential issues."
        }
    }
    catch {
        return @{success = $false; error = $_.Exception.Message }
    }
}

Register-AgentTool -Name "generate_project_template" -Description "Generate a new project structure with dependencies" `
    -Category "Project" -Version "1.0" `
    -Parameters @{
    project_name  = @{
        type        = "string"
        description = "Name of the new project"
        required    = $true
    }
    language      = @{
        type        = "string"
        description = "Primary programming language"
        required    = $true
    }
    template_type = @{
        type        = "string"
        description = "Type of project (console, web, library, etc.)"
        required    = $false
    }
} `
    -Handler {
    param([string]$project_name, [string]$language, [string]$template_type = "console")
    
    try {
        $projectPath = Join-Path $global:currentWorkingDir $project_name
        
        if (Test-Path $projectPath) {
            return @{success = $false; error = "Project directory already exists: $projectPath" }
        }
        
        New-Item -ItemType Directory -Path $projectPath -Force | Out-Null
        $created_files = @()
        
        switch ($language.ToLower()) {
            "python" {
                # Create Python project structure
                $mainFile = Join-Path $projectPath "main.py"
                $requirementsFile = Join-Path $projectPath "requirements.txt"
                
                Set-Content $mainFile @"
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
$project_name - A Python application
"""

def main():
    print("Hello from $project_name!")
    
if __name__ == "__main__":
    main()
"@
                Set-Content $requirementsFile "# Add your dependencies here"
                $created_files += @("main.py", "requirements.txt")
            }
            "javascript" {
                # Create Node.js project
                $packageJson = Join-Path $projectPath "package.json"
                $indexFile = Join-Path $projectPath "index.js"
                
                $packageContent = @{
                    name         = $project_name.ToLower()
                    version      = "1.0.0"
                    description  = "A Node.js application"
                    main         = "index.js"
                    scripts      = @{
                        start = "node index.js"
                    }
                    dependencies = @{}
                } | ConvertTo-Json -Depth 3
                
                Set-Content $packageJson $packageContent
                Set-Content $indexFile @"
console.log('Hello from $project_name!');
"@
                $created_files += @("package.json", "index.js")
            }
            "powershell" {
                # Create PowerShell module
                $moduleFile = Join-Path $projectPath "$project_name.psm1"
                $manifestFile = Join-Path $projectPath "$project_name.psd1"
                
                Set-Content $moduleFile @"
# $project_name PowerShell Module

function Get-$project_name {
    Write-Host "Hello from $project_name!"
}

Export-ModuleMember -Function Get-$project_name
"@
                
                New-ModuleManifest -Path $manifestFile -ModuleVersion "1.0.0" -Description "$project_name PowerShell Module"
                $created_files += @("$project_name.psm1", "$project_name.psd1")
            }
        }
        
        return @{
            success       = $true
            project_name  = $project_name
            project_path  = $projectPath
            language      = $language
            template_type = $template_type
            created_files = $created_files
            message       = "Project '$project_name' created successfully at $projectPath"
        }
    }
    catch {
        return @{success = $false; error = $_.Exception.Message }
    }
}

# ============================================
# AGENT TOOLS COMMAND INTERFACE
# ============================================

function Invoke-AgentTool {
    <#
    .SYNOPSIS
        Execute a registered agent tool by name
    .DESCRIPTION
        Validates parameters and executes the specified tool's handler
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$ToolName,
        
        [Parameter(Mandatory = $false)]
        [hashtable]$Parameters = @{}
    )
    
    if (-not $script:agentTools.ContainsKey($ToolName)) {
        return @{success = $false; error = "Tool not found: $ToolName" }
    }
    
    $tool = $script:agentTools[$ToolName]
    
    # Validate required parameters
    foreach ($paramName in $tool.Parameters.Keys) {
        $paramDef = $tool.Parameters[$paramName]
        if ($paramDef.required -and -not $Parameters.ContainsKey($paramName)) {
            return @{success = $false; error = "Missing required parameter: $paramName" }
        }
    }
    
    # Execute tool handler
    try {
        $result = & $tool.Handler @Parameters
        return $result
    }
    catch {
        return @{success = $false; error = $_.Exception.Message }
    }
}

function Get-AgentToolsList {
    <#
    .SYNOPSIS
        Get a formatted list of all available agent tools
    .DESCRIPTION
        Returns categorized tools with descriptions for display
    #>
    [CmdletBinding()]
    param()
    
    $categories = @{}
    
    foreach ($tool in $script:agentTools.Values) {
        $category = $tool.Category
        if (-not $categories.ContainsKey($category)) {
            $categories[$category] = @()
        }
        
        $categories[$category] += @{
            name        = $tool.Name
            description = $tool.Description
            version     = $tool.Version
            parameters  = $tool.Parameters.Keys -join ", "
        }
    }
    
    return $categories
}

-Parameters @{} `
    -Handler {
    return Get-EnvironmentInfo
}

# ============================================
# Edit Application Engine (Diff/Preview System)
# ============================================
function Set-StructuredEdit {
    param(
        [string]$File,
        [array]$Edits
    )
    
    if (-not (Test-Path $File)) {
        return @{Error = "File not found: $File" }
    }
    
    $originalContent = [System.IO.File]::ReadAllText($File)
    $newContent = $originalContent
    $diffs = @()
    
    foreach ($edit in $Edits) {
        if ($edit.type -eq "replace") {
            $start = $edit.range.start
            $end = $edit.range.end
            $newText = $edit.newText
            
            # Calculate line/column positions
            $lines = $originalContent -split "`r?`n"
            $startPos = 0
            $endPos = 0
            
            for ($i = 0; $i -lt $lines.Count; $i++) {
                if ($i -lt $start.line) {
                    $startPos += $lines[$i].Length + 1
                }
                elseif ($i -eq $start.line) {
                    $startPos += $start.character
                }
                if ($i -lt $end.line) {
                    $endPos += $lines[$i].Length + 1
                }
                elseif ($i -eq $end.line) {
                    $endPos += $end.character
                }
            }
            
            $oldText = $originalContent.Substring($startPos, $endPos - $startPos)
            $diffs += @{
                File    = $File
                OldText = $oldText
                NewText = $newText
                Range   = $edit.range
            }
            
            $newContent = $newContent.Substring(0, $startPos) + $newText + $newContent.Substring($endPos)
        }
    }
    
    # Store pending edit for approval
    $editId = [guid]::NewGuid().ToString()
    $global:agentContext.PendingEdits += @{
        Id              = $editId
        File            = $File
        OriginalContent = $originalContent
        NewContent      = $newContent
        Diffs           = $diffs
        Timestamp       = Get-Date
    }
    
    return @{
        EditId  = $editId
        Diffs   = $diffs
        Preview = Show-EditPreview -EditId $editId
    }
}

function Show-EditPreview {
    param([string]$EditId)
    
    $edit = $global:agentContext.PendingEdits | Where-Object { $_.Id -eq $EditId } | Select-Object -First 1
    if (-not $edit) {
        return $null
    }
    
    $previewForm = New-Object System.Windows.Forms.Form
    $previewForm.Text = "Edit Preview - $($edit.File)"
    $previewForm.Size = New-Object System.Drawing.Size(900, 600)
    $previewForm.StartPosition = "CenterScreen"
    
    $splitter = New-Object System.Windows.Forms.SplitContainer
    $splitter.Dock = [System.Windows.Forms.DockStyle]::Fill
    $splitter.Orientation = [System.Windows.Forms.Orientation]::Vertical
    $previewForm.Controls.Add($splitter) | Out-Null
    
    # Original
    $originalBox = New-Object System.Windows.Forms.RichTextBox
    $originalBox.Dock = [System.Windows.Forms.DockStyle]::Fill
    $originalBox.Text = $edit.OriginalContent
    $originalBox.ReadOnly = $false
    $originalBox.Font = New-Object System.Drawing.Font("Consolas", 9)
    $splitter.Panel1.Controls.Add($originalBox) | Out-Null
    
    # New
    $newBox = New-Object System.Windows.Forms.RichTextBox
    $newBox.Dock = [System.Windows.Forms.DockStyle]::Fill
    $newBox.Text = $edit.NewContent
    $newBox.ReadOnly = $false
    $newBox.Font = New-Object System.Drawing.Font("Consolas", 9)
    $splitter.Panel2.Controls.Add($newBox) | Out-Null
    
    # Buttons
    $buttonPanel = New-Object System.Windows.Forms.Panel
    $buttonPanel.Dock = [System.Windows.Forms.DockStyle]::Bottom
    $buttonPanel.Height = 40
    $previewForm.Controls.Add($buttonPanel) | Out-Null
    
    $approveBtn = New-Object System.Windows.Forms.Button
    $approveBtn.Text = "Approve"
    $approveBtn.Dock = [System.Windows.Forms.DockStyle]::Right
    $approveBtn.Width = 100
    $approveBtn.Add_Click({
            Set-ApprovedEdit -EditId $editId
            $previewForm.Close()
        })
    $buttonPanel.Controls.Add($approveBtn) | Out-Null
    
    $rejectBtn = New-Object System.Windows.Forms.Button
    $rejectBtn.Text = "Reject"
    $rejectBtn.Dock = [System.Windows.Forms.DockStyle]::Right
    $rejectBtn.Width = 100
    $rejectBtn.Add_Click({
            $global:agentContext.PendingEdits = $global:agentContext.PendingEdits | Where-Object { $_.Id -ne $editId }
            $previewForm.Close()
        })
    $buttonPanel.Controls.Add($rejectBtn) | Out-Null
    
    $previewForm.ShowDialog() | Out-Null
}

function Set-ApprovedEdit {
    param([string]$EditId)
    
    $edit = $global:agentContext.PendingEdits | Where-Object { $_.Id -eq $EditId } | Select-Object -First 1
    if ($edit) {
        try {
            [System.IO.File]::WriteAllText($edit.File, $edit.NewContent)
            $global:agentContext.Edits += $edit
            $global:agentContext.PendingEdits = $global:agentContext.PendingEdits | Where-Object { $_.Id -ne $EditId }
            
            # Update editor if file is open
            if ($global:currentFile -eq $edit.File) {
                $editor.Text = $edit.NewContent
            }
            
            return @{success = $true }
        }
        catch {
            return @{Error = $_.Exception.Message }
        }
    }
}

# ============================================
# Dependency Graph & Build System Awareness
# ============================================
function Get-ProjectDependencies {
    param([string]$Path)
    
    $dependencies = @{
        Type         = "Unknown"
        Dependencies = @()
        BuildSystem  = $null
    }
    
    # Detect project type
    if (Test-Path (Join-Path $Path "package.json")) {
        $dependencies.Type = "Node.js"
        $dependencies.BuildSystem = "npm/yarn"
        $pkg = Get-Content (Join-Path $Path "package.json") | ConvertFrom-Json
        $dependencies.Dependencies = @($pkg.dependencies.PSObject.Properties.Name) + @($pkg.devDependencies.PSObject.Properties.Name)
    }
    elseif (Test-Path (Join-Path $Path "requirements.txt")) {
        $dependencies.Type = "Python"
        $dependencies.BuildSystem = "pip"
        $dependencies.Dependencies = Get-Content (Join-Path $Path "requirements.txt")
    }
    elseif (Test-Path (Join-Path $Path "Cargo.toml")) {
        $dependencies.Type = "Rust"
        $dependencies.BuildSystem = "cargo"
        # Parse Cargo.toml would go here
    }
    elseif (Test-Path (Join-Path $Path "go.mod")) {
        $dependencies.Type = "Go"
        $dependencies.BuildSystem = "go"
        # Parse go.mod would go here
    }
    elseif (Test-Path (Join-Path $Path "*.csproj")) {
        $dependencies.Type = ".NET"
        $dependencies.BuildSystem = "dotnet"
        # Parse csproj would go here
    }
    
    $global:agentContext.DependencyGraph[$Path] = $dependencies
    return $dependencies
}

# ============================================
# Environment Awareness
# ============================================
function Get-EnvironmentInfo {
    $env = @{
        OS                = $PSVersionTable.OS
        Platform          = $PSVersionTable.Platform
        PowerShellVersion = $PSVersionTable.PSVersion
        Shell             = "PowerShell"
        Python            = $null
        Node              = $null
        Java              = $null
        DotNet            = $null
    }
    
    # Detect Python
    try {
        $pythonVersion = python --version 2>&1
        $env.Python = $pythonVersion
    }
    catch {}
    
    # Detect Node
    try {
        $nodeVersion = node --version 2>&1
        $env.Node = $nodeVersion
    }
    catch {}
    
    # Detect Java
    try {
        $javaVersion = java -version 2>&1 | Select-Object -First 1
        $env.Java = $javaVersion
    }
    catch {}
    
    # Detect .NET
    try {
        $dotnetVersion = dotnet --version 2>&1
        $env.DotNet = $dotnetVersion
    }
    catch {}
    
    $global:agentContext.Environment = $env
    return $env
}

# ============================================
# Telemetry & Logging System
# ============================================
function Write-AgentLog {
    param(
        [string]$Level,
        [string]$Message,
        [hashtable]$Data = @{}
    )
    
    $logEntry = @{
        Timestamp = Get-Date
        Level     = $Level
        Message   = $Message
        Data      = $Data
        SessionId = $global:agentContext.SessionId
    }
    
    # Store in context
    if (-not $global:agentContext.Logs) {
        $global:agentContext.Logs = @()
    }
    $global:agentContext.Logs += $logEntry
    
    # Write to console if verbose
    $color = switch ($Level) {
        "Error" { "Red" }
        "Warning" { "Yellow" }
        "Info" { "Cyan" }
        default { "White" }
    }
    Write-Host "[$Level] $Message" -ForegroundColor $color
}

# ============================================
# Agent Task Management (Copilot/Amazon Q Workflows)
# ============================================
function New-AgentTask {
    param(
        [string]$Name,
        [string]$Description,
        [array]$Steps
    )
    
    $task = @{
        Id          = [guid]::NewGuid().ToString()
        Name        = $Name
        Description = $Description
        Steps       = $Steps
        Status      = "Pending"
        Progress    = 0
        StartTime   = Get-Date
        EndTime     = $null
        CurrentStep = 0
    }
    
    $global:agentContext.Tasks += $task
    Update-AgentTasksList
    return $task
}

function Start-AgentTask {
    param([string]$TaskId)
    
    $task = $global:agentContext.Tasks | Where-Object { $_.Id -eq $TaskId } | Select-Object -First 1
    if ($task) {
        $task.Status = "Running"
        $agentStatusLabel.Text = "Agent Status: Running - $($task.Name)"
        Update-AgentTasksList
        
        # Execute task steps
        foreach ($step in $task.Steps) {
            $task.CurrentStep++
            $task.Progress = [math]::Round(($task.CurrentStep / $task.Steps.Count) * 100)
            Update-AgentTasksList
            
            Write-AgentLog -Level "Info" -Message "Executing step: $($step.Description)" -Data @{TaskId = $TaskId }
            
            try {
                if ($step.Type -eq "tool") {
                    $result = Invoke-AgentTool -ToolName $step.Tool -Arguments $step.Arguments
                    $step.Result = $result
                    $step.Completed = $true
                }
                elseif ($step.Type -eq "command") {
                    $result = Invoke-TerminalCommand -Command $step.Command
                    $step.Result = $result
                    $step.Completed = $true
                }
                elseif ($step.Type -eq "edit") {
                    $result = Set-StructuredEdit -File $step.File -Edits $step.Edits
                    $step.Result = $result
                    $step.Completed = $true
                }
            }
            catch {
                $step.Error = $_.Exception.Message
                $task.Status = "Error"
                Write-AgentLog -Level "Error" -Message "Task step failed: $($_.Exception.Message)" -Data @{TaskId = $TaskId; Step = $step.Description }
                break
            }
        }
        
        if ($task.Status -ne "Error") {
            $task.Status = "Completed"
            $task.EndTime = Get-Date
            $task.Progress = 100
        }
        
        $agentStatusLabel.Text = "Agent Status: $($task.Status) - $($task.Name)"
        Update-AgentTasksList
        Write-AgentLog -Level "Info" -Message "Task completed: $($task.Name)" -Data @{TaskId = $TaskId; Status = $task.Status }
    }
}

function Update-AgentTasksList {
    $agentTasksList.Items.Clear()
    foreach ($task in $global:agentContext.Tasks) {
        $item = New-Object System.Windows.Forms.ListViewItem($task.Name)
        $item.SubItems.Add($task.Status) | Out-Null
        $item.SubItems.Add("$($task.Progress)%") | Out-Null
        $item.SubItems.Add((New-TimeSpan -Start $task.StartTime -End (if ($task.EndTime) { $task.EndTime } else { Get-Date })).ToString("mm\:ss")) | Out-Null
        $item.Tag = $task.Id
        $agentTasksList.Items.Add($item) | Out-Null
    }
}

# ============================================
# Agentic Workflow Execution
# ============================================
function Invoke-AgenticWorkflow {
    param(
        [string]$Goal,
        [string]$Context = ""
    )
    
    Write-AgentLog -Level "Info" -Message "Starting agentic workflow" -Data @{Goal = $Goal }
    
    # Create task from goal
    $steps = @()
    
    # Analyze goal and create steps
    if ($Goal -match "create|generate|write") {
        $steps += @{
            Type        = "tool"
            Description = "Analyze requirements"
            Tool        = "get_environment"
            Arguments   = @{}
        }
        $steps += @{
            Type        = "tool"
            Description = "Check project structure"
            Tool        = "list_directory"
            Arguments   = @{path = $global:currentWorkingDir }
        }
    }
    
    if ($Goal -match "fix|debug|error") {
        $steps += @{
            Type        = "tool"
            Description = "Read error files"
            Tool        = "read_file"
            Arguments   = @{path = $global:currentFile }
        }
        $steps += @{
            Type        = "command"
            Description = "Run tests to identify issues"
            Command     = "Get-ChildItem -Recurse -Filter '*test*' | Select-Object -First 1"
        }
    }
    
    if ($Goal -match "refactor|improve") {
        $steps += @{
            Type        = "tool"
            Description = "Read source files"
            Tool        = "read_file"
            Arguments   = @{path = $global:currentFile }
        }
        $steps += @{
            Type        = "edit"
            Description = "Apply refactoring"
            File        = $global:currentFile
            Edits       = @() # Would be generated by AI
        }
    }
    
    $task = New-AgentTask -Name $Goal -Description $Context -Steps $steps
    Start-AgentTask -TaskId $task.Id
    
    return $task
}

# ============================================
# Coding/Copilot Functions
# ============================================
function Invoke-CodeGeneration {
    param([string]$prompt, [string]$context = "")
    
    $fullPrompt = @"
You are a coding assistant. Generate code based on the following request.

Request: $prompt

$context

Provide only the code, no explanations unless asked.
"@
    
    return Send-OllamaRequest $fullPrompt
}

function Invoke-CodeReview {
    param([string]$code)
    
    # Detect language from content
    $language = "Unknown"
    if ($code -match "function\s+\w+\s*\{" -or $code -match "\$\w+" -or $code -match "param\s*\(") {
        $language = "PowerShell"
    }
    elseif ($code -match "def\s+\w+\s*\(" -or $code -match "import\s+" -or $code -match "print\s*\(") {
        $language = "Python"
    }
    elseif ($code -match "function\s+\w+\s*\(" -or $code -match "console\.log" -or $code -match "var\s+\w+" -or $code -match "const\s+\w+") {
        $language = "JavaScript"
    }
    elseif ($code -match "#include\s*<" -or $code -match "int\s+main\s*\(" -or $code -match "printf\s*\(") {
        $language = "C/C++"
    }
    
    $prompt = @"
You are an expert code reviewer. Analyze this $language code and provide a comprehensive review.

CODE TO REVIEW:
```$language
$code
```

Please provide a detailed code review with:

1. **CODE QUALITY ASSESSMENT**
   - Overall code structure and organization
   - Readability and maintainability
   - Naming conventions
   - Code complexity

2. **ISSUES FOUND**
   - Syntax errors or potential bugs
   - Performance problems
   - Security vulnerabilities
   - Logic errors

3. **IMPROVEMENT SUGGESTIONS**
   - Specific code changes recommended
   - Better algorithms or approaches
   - Optimization opportunities
   - Missing error handling

4. **BEST PRACTICES**
   - Language-specific best practices
   - Design patterns that could be applied
   - Documentation improvements
   - Testing recommendations

5. **OVERALL RATING**
   - Rate the code from 1-10 (10 being excellent)
   - Summary of strengths and weaknesses

Be specific and provide actionable feedback with examples where possible.
"@
    
    Write-DevConsole "Sending code review request to model..." "INFO"
    return Send-OllamaRequest $prompt
}

function Invoke-CodeRefactor {
    param([string]$code, [string]$instructions)
    
    $prompt = @"
Refactor this code according to the instructions:

Instructions: $instructions

Code:
$code

Provide the refactored code.
"@
    
    return Send-OllamaRequest $prompt
}

# Input Box Event Handler
$inputBox.Add_KeyDown({
        if ($_.KeyCode -eq "Enter" -and $_.Control -eq $false) {
            $message = $inputBox.Text.Trim()
            if ($message) {
                $inputBox.Clear()
                Send-Chat $message
            }
        }
    })

# File Explorer Event Handlers
$explorer.Add_BeforeExpand({
        $node = $_.Node
        Write-DevConsole "BeforeExpand event triggered for: $($node.Text)" "DEBUG"
        Write-DevConsole "Node Tag: $($node.Tag)" "DEBUG"
        Write-DevConsole "Node has $($node.Nodes.Count) child nodes" "DEBUG"
        
        try {
            Expand-ExplorerNode $node
        }
        catch {
            Write-DevConsole "Error in BeforeExpand event: $_" "ERROR"
        }
    })

$explorer.Add_NodeMouseDoubleClick({
        $node = $_.Node
        if ($node.Tag -and $node.Tag -ne "DUMMY" -and (Test-Path $node.Tag)) {
            $path = $node.Tag
            Write-DevConsole "Double-clicked: $path" "DEBUG"
            
            if (-not (Test-Path $path -PathType Container)) {
                # This is a file - open it in the editor
                try {
                    $content = [System.IO.File]::ReadAllText($path)
                    $editor.Text = $content
                    $global:currentFile = $path
                    $global:currentWorkingDir = Split-Path $path
                    $form.Text = "AI Text Editor - $(Split-Path -Leaf $path)"
                    $explorerPathLabel.Text = "Path: $(Split-Path $path)"
                    
                    Write-DevConsole "Opened file: $path ($($content.Length) characters)" "SUCCESS"
                    
                    # Auto-switch to editor if we have tabbed interface
                    if ($leftSplitter) {
                        $leftSplitter.Panel2.Focus()
                    }
                }
                catch {
                    Write-DevConsole "‚ùå Error opening file: $path - $_" "ERROR"
                }
            }
            else {
                # This is a folder - navigate to it
                $global:currentWorkingDir = $path
                $explorerPathLabel.Text = "Path: $path"
                Set-Location $path
                Write-DevConsole "Navigated to folder: $path" "INFO"
                
                # Refresh the file browser to reflect new working directory
                # Update-Explorer
            }
        }
    })

# Add right-click context menu for file explorer
$explorerContextMenu = New-Object System.Windows.Forms.ContextMenuStrip

# Create context menu items
$openFileMenuItem = New-Object System.Windows.Forms.ToolStripMenuItem("Open File")
$openFolderMenuItem = New-Object System.Windows.Forms.ToolStripMenuItem("Open Folder in Explorer") 
$copyPathMenuItem = New-Object System.Windows.Forms.ToolStripMenuItem("Copy Path")
$refreshMenuItem = New-Object System.Windows.Forms.ToolStripMenuItem("Refresh")

$explorerContextMenu.Items.AddRange(@($openFileMenuItem, $openFolderMenuItem, $copyPathMenuItem, $refreshMenuItem))
$explorer.ContextMenuStrip = $explorerContextMenu

# Context menu event handlers
$openFileMenuItem.Add_Click({
        $selectedNode = $explorer.SelectedNode
        if ($selectedNode -and $selectedNode.Tag -and (Test-Path $selectedNode.Tag -PathType Leaf)) {
            # Trigger the same action as double-click
            $explorer.SelectedNode = $selectedNode
            $fakeEventArgs = New-Object System.Windows.Forms.TreeNodeMouseClickEventArgs($selectedNode, [System.Windows.Forms.MouseButtons]::Left, 2, 0, 0)
            $explorer.OnNodeMouseDoubleClick($fakeEventArgs)
        }
    })

$openFolderMenuItem.Add_Click({
        $selectedNode = $explorer.SelectedNode
        if ($selectedNode -and $selectedNode.Tag -and (Test-Path $selectedNode.Tag)) {
            $folder = if (Test-Path $selectedNode.Tag -PathType Container) { $selectedNode.Tag } else { Split-Path $selectedNode.Tag }
            Start-Process "explorer.exe" -ArgumentList $folder
        }
    })

$copyPathMenuItem.Add_Click({
        $selectedNode = $explorer.SelectedNode
        if ($selectedNode -and $selectedNode.Tag) {
            [System.Windows.Forms.Clipboard]::SetText($selectedNode.Tag)
            Write-DevConsole "Copied path to clipboard: $($selectedNode.Tag)" "INFO"
        }
    })

$refreshMenuItem.Add_Click({
        Write-DevConsole "Refreshing file browser..." "INFO"
        Update-Explorer
    })

# Explorer toolbar button event handlers
$explorerRefreshBtn.Add_Click({
        Write-DevConsole "Refreshing file browser..." "INFO"
        Update-Explorer
    })

$explorerUpBtn.Add_Click({
        if ($global:currentWorkingDir) {
            $parentDir = Split-Path $global:currentWorkingDir -Parent
            if ($parentDir -and (Test-Path $parentDir)) {
                $global:currentWorkingDir = $parentDir
                Set-Location $parentDir
                $explorerPathLabel.Text = "Path: $parentDir"
                Update-Explorer
                Write-DevConsole "Navigated up to: $parentDir" "INFO"
            }
            else {
                Write-DevConsole "Already at root directory" "WARNING"
            }
        }
    })

# Terminal Event Handlers
$terminalInput.Add_KeyDown({
        if ($_.KeyCode -eq "Enter") {
            $command = $terminalInput.Text.Trim()
            $terminalInput.Clear()
            Invoke-TerminalCommand $command
        }
        elseif ($_.KeyCode -eq "Up") {
            if ($global:terminalHistoryIndex -gt 0) {
                $global:terminalHistoryIndex--
                $terminalInput.Text = $global:terminalHistory[$global:terminalHistoryIndex]
            }
            $_.Handled = $true
        }
        elseif ($_.KeyCode -eq "Down") {
            if ($global:terminalHistoryIndex -lt ($global:terminalHistory.Count - 1)) {
                $global:terminalHistoryIndex++
                $terminalInput.Text = $global:terminalHistory[$global:terminalHistoryIndex]
            }
            else {
                $terminalInput.Text = ""
                $global:terminalHistoryIndex = $global:terminalHistory.Count
            }
            $_.Handled = $true
        }
    })

# Agent Tasks Event Handlers
$agentSendBtn.Add_Click({
        $command = $agentInputBox.Text.Trim()
        if ($command) {
            Send-AgentCommand $command
            $agentInputBox.Clear()
        }
    })

$agentInputBox.Add_KeyDown({
        if ($_.KeyCode -eq "Enter") {
            $command = $agentInputBox.Text.Trim()
            if ($command) {
                Send-AgentCommand $command
                $agentInputBox.Clear()
            }
            $_.Handled = $true
        }
    })

# Agent Command Processing Function
function Send-AgentCommand {
    param([string]$command)
    
    # Display command in agent console
    $agentTaskDetails.AppendText("[$(Get-Date -Format 'HH:mm:ss')] > $command`r`n")
    $agentTaskDetails.ScrollToCaret()
    
    Write-DevConsole "Agent command received: $command" "INFO"
    
    # Process the command
    try {
        if ($command -match "^/help$" -or $command -eq "help") {
            $agentTaskDetails.AppendText("Available Agent Commands:`r`n")
            $agentTaskDetails.AppendText("  /help - Show this help`r`n")
            $agentTaskDetails.AppendText("  /status - Show agent status`r`n")
            $agentTaskDetails.AppendText("  /tasks - List current tasks`r`n")
            $agentTaskDetails.AppendText("  /clear - Clear console`r`n")
            $agentTaskDetails.AppendText("  /tools - List available tools`r`n")
            $agentTaskDetails.AppendText("  /execute_tool <name> <params> - Execute a tool`r`n")
            $agentTaskDetails.AppendText("  Any other text will be sent to the AI for processing`r`n`r`n")
        }
        elseif ($command -eq "/clear") {
            $agentTaskDetails.Clear()
            $agentTaskDetails.AppendText("Agent Task Console - Cleared`r`n")
        }
        elseif ($command -eq "/status") {
            $agentTaskDetails.AppendText("Agent Status: Online`r`n")
            $agentTaskDetails.AppendText("Model: $($global:settings.OllamaModel)`r`n")
            $agentTaskDetails.AppendText("Tasks: $($global:agentContext.Tasks.Count)`r`n")
            $agentTaskDetails.AppendText("Session: $($global:agentContext.SessionId)`r`n`r`n")
        }
        elseif ($command -eq "/tasks") {
            $agentTaskDetails.AppendText("Current Tasks:`r`n")
            if ($global:agentContext.Tasks.Count -eq 0) {
                $agentTaskDetails.AppendText("  No active tasks`r`n")
            }
            else {
                foreach ($task in $global:agentContext.Tasks) {
                    $agentTaskDetails.AppendText("  - $($task.Name) [$($task.Status)]`r`n")
                }
            }
            $agentTaskDetails.AppendText("`r`n")
        }
        elseif ($command -eq "/tools") {
            $categories = Get-AgentToolsList
            $agentTaskDetails.AppendText("Available Tools:`r`n")
            foreach ($category in $categories.Keys) {
                $agentTaskDetails.AppendText("  $category :`r`n")
                foreach ($tool in $categories[$category]) {
                    $agentTaskDetails.AppendText("    ‚Ä¢ $($tool.name) - $($tool.description)`r`n")
                }
            }
            $agentTaskDetails.AppendText("`r`n")
        }
        elseif ($command -match "^/execute_tool\s+(\w+)(?:\s+(.+))?$") {
            $toolName = $Matches[1]
            $paramsJson = if ($Matches[2]) { $Matches[2] } else { "{}" }
            
            try {
                $params = ConvertFrom-Json $paramsJson -AsHashtable
                $result = Invoke-AgentTool -ToolName $toolName -Parameters $params
                
                $agentTaskDetails.AppendText("Tool Result: $toolName`r`n")
                if ($result.success) {
                    $agentTaskDetails.AppendText("‚úì Success`r`n")
                    $resultJson = ($result | ConvertTo-Json -Depth 3)
                    $agentTaskDetails.AppendText("$resultJson`r`n`r`n")
                }
                else {
                    $agentTaskDetails.AppendText("‚úó Error: $($result.error)`r`n`r`n")
                }
            }
            catch {
                $agentTaskDetails.AppendText("‚úó Tool execution error: $_`r`n`r`n")
            }
        }
        else {
            # Send to AI for processing
            $agentTaskDetails.AppendText("Processing with AI...`r`n")
            $agentResponse = Send-OllamaRequest $command $global:settings.OllamaModel
            $agentTaskDetails.AppendText("AI Response: $agentResponse`r`n`r`n")
        }
    }
    catch {
        $agentTaskDetails.AppendText("Error processing command: $_`r`n`r`n")
        Write-DevConsole "Agent command error: $_" "ERROR"
    }
    
    $agentTaskDetails.ScrollToCaret()
}

# Git Refresh Handler
$gitRefreshBtn.Add_Click({
        Update-GitStatus
    })

# Initialize Explorer
Update-Explorer

# Initialize Extension System
Initialize-ExtensionSystem

# Load user settings
try {
    $script:settingsLoader = { Get-Settings }  # Fixed verb name
    Invoke-Command $script:settingsLoader
    Write-DevConsole "User settings loaded successfully" "SUCCESS"
}
catch {
    Write-DevConsole "Could not load settings, using defaults: $_" "WARNING"
}

# Initialize Agentic System
Get-EnvironmentInfo | Out-Null
Write-AgentLog -Level "Info" -Message "Agentic system initialized" -Data @{SessionId = $global:agentContext.SessionId }

# Load chat history on startup and show welcome message
$form.Add_Load({
        Get-ChatHistory
        
        # Show agent mode status on startup
        if ($global:AgentMode) {
            $chatBox.AppendText("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`r`n")
            $chatBox.AppendText("     ü§ñ RawrXD AI Editor - Agent Mode ACTIVE ü§ñ     `r`n")
            $chatBox.AppendText("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`r`n")
            $chatBox.AppendText("Agentic features enabled! Talk naturally or use commands:`r`n`r`n")
            
            $chatBox.AppendText("üìù CODE & EDITING:`r`n")
            $chatBox.AppendText("  ‚Ä¢ /review - Review code in editor`r`n")
            $chatBox.AppendText("  ‚Ä¢ /code <description> - Generate code`r`n")
            $chatBox.AppendText("  ‚Ä¢ /refactor <instructions> - Refactor code`r`n")
            $chatBox.AppendText("  ‚Ä¢ 'open file test.js' - Open any file`r`n")
            $chatBox.AppendText("  ‚Ä¢ 'save this file as backup.txt' - Save file`r`n")
            $chatBox.AppendText("  ‚Ä¢ 'create new file app.py' - Create new file`r`n`r`n")
            
            $chatBox.AppendText("üìÅ FILE BROWSING:`r`n")
            $chatBox.AppendText("  ‚Ä¢ 'show files in C:\Projects' - List directory`r`n")
            $chatBox.AppendText("  ‚Ä¢ 'go to folder Documents' - Change directory`r`n")
            $chatBox.AppendText("  ‚Ä¢ 'open project MyApp' - Open folder/project`r`n")
            $chatBox.AppendText("  ‚Ä¢ /ls, /cd, /dir - Classic commands work too`r`n`r`n")
            
            $chatBox.AppendText("üåê BROWSER:`r`n")
            $chatBox.AppendText("  ‚Ä¢ 'open google.com' - Navigate to URL`r`n")
            $chatBox.AppendText("  ‚Ä¢ 'search for AI tutorials' - Google search`r`n")
            $chatBox.AppendText("  ‚Ä¢ 'youtube search cats' - Search YouTube`r`n")
            $chatBox.AppendText("  ‚Ä¢ 'extract page content' - Get webpage text`r`n`r`n")
            
            $chatBox.AppendText("üíª TERMINAL:`r`n")
            $chatBox.AppendText("  ‚Ä¢ 'run command npm install' - Execute commands`r`n")
            $chatBox.AppendText("  ‚Ä¢ /term <cmd>, /exec <cmd> - Run in terminal`r`n")
            $chatBox.AppendText("  ‚Ä¢ 'show terminal' - Switch to terminal tab`r`n`r`n")
            
            $chatBox.AppendText("üîß AGENT TOOLS & AUTOMATION:`r`n")
            $chatBox.AppendText("  ‚Ä¢ /tools - Show all 15+ registered agent tools`r`n")
            $chatBox.AppendText("  ‚Ä¢ /tools Browser - Filter tools by category`r`n")
            $chatBox.AppendText("  ‚Ä¢ /execute_tool read_file {`"path`":`"file.txt`"}`r`n")
            $chatBox.AppendText("  ‚Ä¢ /git status, /git commit, /git push`r`n")
            $chatBox.AppendText("  ‚Ä¢ /workflow <goal> - Multi-step tasks`r`n`r`n")
            
            $chatBox.AppendText("üí° TIP: Just type naturally! The agent understands context.`r`n")
            $chatBox.AppendText("üí° Type '/tools' to see FileSystem, Git, Browser, Terminal tools!`r`n")
            $chatBox.AppendText("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`r`n`r`n")
        }
    })

# Add controls to form
$form.Controls.Add($mainSplitter) | Out-Null
$form.Controls.Add($menu) | Out-Null

# Global error handler
$form.Add_Shown({
        Write-DevConsole "RawrXD Form Loaded Successfully" "SUCCESS"
        Write-DevConsole "Agent Mode: $(if ($global:AgentMode) { 'ON' } else { 'OFF' })" "INFO"
        Write-DevConsole "Current Directory: $global:currentWorkingDir" "INFO"
        
        # Start Ollama server automatically
        if (-not $global:ollamaStartupAttempted) {
            $global:ollamaStartupAttempted = $true
            Write-DevConsole "Auto-starting Ollama server..." "INFO"
            Start-OllamaServer | Out-Null
        }
        
        # Set up a timer to update status periodically (only if not already created)
        if (-not $script:ollamaTimer) {
            $script:ollamaTimer = New-Object System.Windows.Forms.Timer
            $script:ollamaTimer.Interval = 2000  # Check every 2 seconds
            $script:ollamaTimer.Add_Tick({
                    Update-OllamaStatusDisplay
                })
            $script:ollamaTimer.Start()
        }
        
        # Update initial status
        Update-OllamaStatusDisplay
    })# Capture all unhandled exceptions
$null = Register-ObjectEvent -InputObject ([System.AppDomain]::CurrentDomain) -EventName UnhandledException -Action {
    $errorMsg = $Event.SourceEventArgs.ExceptionObject.ToString()
    Write-DevConsole "UNHANDLED EXCEPTION: $errorMsg" "ERROR"
}

# Error handling for form display
Write-StartupLog "Starting RawrXD main application..." "INFO"
try {
    Write-StartupLog "Initializing main form..." "INFO"
    Write-StartupLog "Application startup completed successfully!" "SUCCESS"
    Write-StartupLog "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" "SUCCESS"
    Write-StartupLog "SESSION LOG: Check Dev Tools tab for runtime logs" "INFO"
    Write-StartupLog "STARTUP LOG: $script:startupLogPath" "INFO"
    Write-StartupLog "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" "INFO"
    
    # Add form closing event to cleanup Ollama server
    $form.Add_FormClosing({
            param($formSender, $formArgs)
            try {
                Write-DevConsole "Application closing - cleaning up Ollama server..." "INFO"
                
                # Safely cleanup the Ollama timer if it exists
                if ((Get-Variable -Name "ollamaTimer" -Scope Script -ErrorAction SilentlyContinue) -and $script:ollamaTimer) {
                    try {
                        $script:ollamaTimer.Stop()
                        $script:ollamaTimer.Dispose()
                        Write-DevConsole "Ollama timer stopped and disposed" "INFO"
                    }
                    catch {
                        Write-DevConsole "Error stopping Ollama timer: $_" "WARNING"
                    }
                }
                
                # Note: We don't auto-stop Ollama server on exit as it might be used by other apps
                # Users can manually stop it using the Stop button if desired
                Write-DevConsole "Application cleanup completed" "INFO"
            }
            catch {
                Write-DevConsole "Error during application cleanup: $_" "ERROR"
                # Don't prevent form from closing even if cleanup fails
            }
        })
    
    $form.ShowDialog() | Out-Null
}
catch {
    $errorMsg = $_.Exception.Message
    Write-StartupLog "CRITICAL ERROR during application startup: $errorMsg" "ERROR"
    Write-StartupLog "Stack trace: $($_.ScriptStackTrace)" "ERROR"
    Write-DevConsole "FATAL ERROR: $errorMsg" "ERROR"
    Write-DevConsole "‚ùå Critical startup failure - Check startup log: $script:startupLogPath" "ERROR"
    exit 1
}

# Application closing
Write-StartupLog "RawrXD application session ended" "INFO"
Write-StartupLog "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" "INFO"


